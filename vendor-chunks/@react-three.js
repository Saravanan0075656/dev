"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/PointMaterial.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/PointMaterial.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointMaterial: () => (/* binding */ PointMaterial),\n/* harmony export */   PointMaterialImpl: () => (/* binding */ PointMaterialImpl)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/constants.js */ \"(ssr)/./node_modules/@react-three/drei/helpers/constants.js\");\n\n\n\n\nconst opaque_fragment = _helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? \"opaque_fragment\" : \"output_fragment\";\nclass PointMaterialImpl extends three__WEBPACK_IMPORTED_MODULE_3__.PointsMaterial {\n    constructor(props){\n        super(props);\n        this.onBeforeCompile = (shader, renderer)=>{\n            const { isWebGL2 } = renderer.capabilities;\n            shader.fragmentShader = shader.fragmentShader.replace(`#include <${opaque_fragment}>`, `\n        ${!isWebGL2 ? `#extension GL_OES_standard_derivatives : enable\\n#include <${opaque_fragment}>` : `#include <${opaque_fragment}>`}\n      vec2 cxy = 2.0 * gl_PointCoord - 1.0;\n      float r = dot(cxy, cxy);\n      float delta = fwidth(r);     \n      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\n      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );\n      #include <tonemapping_fragment>\n      #include <${_helpers_constants_js__WEBPACK_IMPORTED_MODULE_2__.version >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n      `);\n        };\n    }\n}\nconst PointMaterial = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref)=>{\n    const [material] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new PointMaterialImpl(null));\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        object: material,\n        ref: ref,\n        attach: \"material\"\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Qb2ludE1hdGVyaWFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDQTtBQUNtQjtBQUVsRCxNQUFNSSxrQkFBa0JELDBEQUFPQSxJQUFJLE1BQU0sb0JBQW9CO0FBQzdELE1BQU1FLDBCQUEwQkosaURBQW9CO0lBQ2xETSxZQUFZQyxLQUFLLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsZUFBZSxHQUFHLENBQUNDLFFBQVFDO1lBQzlCLE1BQU0sRUFDSkMsUUFBUSxFQUNULEdBQUdELFNBQVNFLFlBQVk7WUFDekJILE9BQU9JLGNBQWMsR0FBR0osT0FBT0ksY0FBYyxDQUFDQyxPQUFPLENBQUMsQ0FBQyxVQUFVLEVBQUVYLGdCQUFnQixDQUFDLENBQUMsRUFBRSxDQUFDO1FBQ3RGLEVBQUUsQ0FBQ1EsV0FBVyxDQUFDLDJEQUEyRCxFQUFFUixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUVBLGdCQUFnQixDQUFDLENBQUMsQ0FBQzs7Ozs7OztnQkFPekgsRUFBRUQsMERBQU9BLElBQUksTUFBTSx3QkFBd0IscUJBQXFCO01BQzFFLENBQUM7UUFDSDtJQUNGO0FBQ0Y7QUFDQSxNQUFNYSxnQkFBZ0IsYUFBYSxpQkFBRWQsNkNBQWdCLENBQUMsQ0FBQ00sT0FBT1U7SUFDNUQsTUFBTSxDQUFDQyxTQUFTLEdBQUdqQiwyQ0FBYyxDQUFDLElBQU0sSUFBSUcsa0JBQWtCO0lBQzlELE9BQU8sV0FBVyxHQUFFSCxnREFBbUIsQ0FBQyxhQUFhRiw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdRLE9BQU87UUFDdkVjLFFBQVFIO1FBQ1JELEtBQUtBO1FBQ0xLLFFBQVE7SUFDVjtBQUNGO0FBRTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2UtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvUG9pbnRNYXRlcmlhbC5qcz9kYTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tICcuLi9oZWxwZXJzL2NvbnN0YW50cy5qcyc7XG5cbmNvbnN0IG9wYXF1ZV9mcmFnbWVudCA9IHZlcnNpb24gPj0gMTU0ID8gJ29wYXF1ZV9mcmFnbWVudCcgOiAnb3V0cHV0X2ZyYWdtZW50JztcbmNsYXNzIFBvaW50TWF0ZXJpYWxJbXBsIGV4dGVuZHMgVEhSRUUuUG9pbnRzTWF0ZXJpYWwge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLm9uQmVmb3JlQ29tcGlsZSA9IChzaGFkZXIsIHJlbmRlcmVyKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlzV2ViR0wyXG4gICAgICB9ID0gcmVuZGVyZXIuY2FwYWJpbGl0aWVzO1xuICAgICAgc2hhZGVyLmZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyLnJlcGxhY2UoYCNpbmNsdWRlIDwke29wYXF1ZV9mcmFnbWVudH0+YCwgYFxuICAgICAgICAkeyFpc1dlYkdMMiA/IGAjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbiNpbmNsdWRlIDwke29wYXF1ZV9mcmFnbWVudH0+YCA6IGAjaW5jbHVkZSA8JHtvcGFxdWVfZnJhZ21lbnR9PmB9XG4gICAgICB2ZWMyIGN4eSA9IDIuMCAqIGdsX1BvaW50Q29vcmQgLSAxLjA7XG4gICAgICBmbG9hdCByID0gZG90KGN4eSwgY3h5KTtcbiAgICAgIGZsb2F0IGRlbHRhID0gZndpZHRoKHIpOyAgICAgXG4gICAgICBmbG9hdCBtYXNrID0gMS4wIC0gc21vb3Roc3RlcCgxLjAgLSBkZWx0YSwgMS4wICsgZGVsdGEsIHIpO1xuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChnbF9GcmFnQ29sb3IucmdiLCBtYXNrICogZ2xfRnJhZ0NvbG9yLmEgKTtcbiAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgICNpbmNsdWRlIDwke3ZlcnNpb24gPj0gMTU0ID8gJ2NvbG9yc3BhY2VfZnJhZ21lbnQnIDogJ2VuY29kaW5nc19mcmFnbWVudCd9PlxuICAgICAgYCk7XG4gICAgfTtcbiAgfVxufVxuY29uc3QgUG9pbnRNYXRlcmlhbCA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgY29uc3QgW21hdGVyaWFsXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBQb2ludE1hdGVyaWFsSW1wbChudWxsKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBvYmplY3Q6IG1hdGVyaWFsLFxuICAgIHJlZjogcmVmLFxuICAgIGF0dGFjaDogXCJtYXRlcmlhbFwiXG4gIH0pKTtcbn0pO1xuXG5leHBvcnQgeyBQb2ludE1hdGVyaWFsLCBQb2ludE1hdGVyaWFsSW1wbCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiVEhSRUUiLCJSZWFjdCIsInZlcnNpb24iLCJvcGFxdWVfZnJhZ21lbnQiLCJQb2ludE1hdGVyaWFsSW1wbCIsIlBvaW50c01hdGVyaWFsIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsIm9uQmVmb3JlQ29tcGlsZSIsInNoYWRlciIsInJlbmRlcmVyIiwiaXNXZWJHTDIiLCJjYXBhYmlsaXRpZXMiLCJmcmFnbWVudFNoYWRlciIsInJlcGxhY2UiLCJQb2ludE1hdGVyaWFsIiwiZm9yd2FyZFJlZiIsInJlZiIsIm1hdGVyaWFsIiwidXNlU3RhdGUiLCJjcmVhdGVFbGVtZW50Iiwib2JqZWN0IiwiYXR0YWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/PointMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Points.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Points.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   Points: () => (/* binding */ Points),\n/* harmony export */   PointsBuffer: () => (/* binding */ PointsBuffer),\n/* harmony export */   PositionPoint: () => (/* binding */ PositionPoint)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-710fb441.esm.js\");\n/* harmony import */ var react_merge_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-merge-refs */ \"(ssr)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js\");\n\n\n\n\n\nconst _inverseMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst _ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Ray();\nconst _sphere = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\nconst _position = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nclass PositionPoint extends three__WEBPACK_IMPORTED_MODULE_3__.Group {\n    constructor(){\n        super();\n        this.size = 0;\n        this.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color(\"white\");\n        this.instance = {\n            current: undefined\n        };\n        this.instanceKey = {\n            current: undefined\n        };\n    }\n    // This will allow the virtual instance have bounds\n    get geometry() {\n        var _this$instance$curren;\n        return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n    }\n    raycast(raycaster, intersects) {\n        var _raycaster$params$Poi, _raycaster$params$Poi2;\n        const parent = this.instance.current;\n        if (!parent || !parent.geometry) return;\n        const instanceId = parent.userData.instances.indexOf(this.instanceKey);\n        // If the instance wasn't found or exceeds the parents draw range, bail out\n        if (instanceId === -1 || instanceId > parent.geometry.drawRange.count) return;\n        const threshold = (_raycaster$params$Poi = (_raycaster$params$Poi2 = raycaster.params.Points) == null ? void 0 : _raycaster$params$Poi2.threshold) !== null && _raycaster$params$Poi !== void 0 ? _raycaster$params$Poi : 1;\n        _sphere.set(this.getWorldPosition(_position), threshold);\n        if (raycaster.ray.intersectsSphere(_sphere) === false) return;\n        _inverseMatrix.copy(parent.matrixWorld).invert();\n        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n        const localThresholdSq = localThreshold * localThreshold;\n        const rayPointDistanceSq = _ray.distanceSqToPoint(this.position);\n        if (rayPointDistanceSq < localThresholdSq) {\n            const intersectPoint = new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n            _ray.closestPointToPoint(this.position, intersectPoint);\n            intersectPoint.applyMatrix4(this.matrixWorld);\n            const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n            if (distance < raycaster.near || distance > raycaster.far) return;\n            intersects.push({\n                distance: distance,\n                distanceToRay: Math.sqrt(rayPointDistanceSq),\n                point: intersectPoint,\n                index: instanceId,\n                face: null,\n                object: this\n            });\n        }\n    }\n}\nlet i, positionRef;\nconst context = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nconst parentMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst position = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\n/**\n * Instance implementation, relies on react + context to update the attributes based on the children of this component\n */ const PointsInstances = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, range, limit = 1000, ...props }, ref)=>{\n    const parentRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const [refs, setRefs] = react__WEBPACK_IMPORTED_MODULE_1__.useState([]);\n    const [[positions, colors, sizes]] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>[\n            new Float32Array(limit * 3),\n            Float32Array.from({\n                length: limit * 3\n            }, ()=>1),\n            Float32Array.from({\n                length: limit\n            }, ()=>1)\n        ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        // We might be a frame too late? 🤷‍♂️\n        parentRef.current.geometry.attributes.position.needsUpdate = true;\n    });\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)(()=>{\n        parentRef.current.updateMatrix();\n        parentRef.current.updateMatrixWorld();\n        parentMatrix.copy(parentRef.current.matrixWorld).invert();\n        parentRef.current.geometry.drawRange.count = Math.min(limit, range !== undefined ? range : limit, refs.length);\n        for(i = 0; i < refs.length; i++){\n            positionRef = refs[i].current;\n            positionRef.getWorldPosition(position).applyMatrix4(parentMatrix);\n            position.toArray(positions, i * 3);\n            parentRef.current.geometry.attributes.position.needsUpdate = true;\n            positionRef.matrixWorldNeedsUpdate = true;\n            positionRef.color.toArray(colors, i * 3);\n            parentRef.current.geometry.attributes.color.needsUpdate = true;\n            sizes.set([\n                positionRef.size\n            ], i);\n            parentRef.current.geometry.attributes.size.needsUpdate = true;\n        }\n    });\n    const api = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            getParent: ()=>parentRef,\n            subscribe: (ref)=>{\n                setRefs((refs)=>[\n                        ...refs,\n                        ref\n                    ]);\n                return ()=>setRefs((refs)=>refs.filter((item)=>item.current !== ref.current));\n            }\n        }), []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"points\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        userData: {\n            instances: refs\n        },\n        matrixAutoUpdate: false,\n        ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            ref,\n            parentRef\n        ]),\n        raycast: ()=>null\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferGeometry\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-position\",\n        count: positions.length / 3,\n        array: positions,\n        itemSize: 3,\n        usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-color\",\n        count: colors.length / 3,\n        array: colors,\n        itemSize: 3,\n        usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-size\",\n        count: sizes.length,\n        array: sizes,\n        itemSize: 1,\n        usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n    })), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(context.Provider, {\n        value: api\n    }, children));\n});\nconst Point = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, ...props }, ref)=>{\n    react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.e)({\n            PositionPoint\n        }), []);\n    const group = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n    const { subscribe, getParent } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(context);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>subscribe(group), []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"positionPoint\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        instance: getParent(),\n        instanceKey: group,\n        ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            ref,\n            group\n        ])\n    }, props), children);\n});\n/**\n * Buffer implementation, relies on complete buffers of the correct number, leaves it to the user to update them\n */ const PointsBuffer = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ children, positions, colors, sizes, stride = 3, ...props }, forwardedRef)=>{\n    const pointsRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.C)(()=>{\n        const attr = pointsRef.current.geometry.attributes;\n        attr.position.needsUpdate = true;\n        if (colors) attr.color.needsUpdate = true;\n        if (sizes) attr.size.needsUpdate = true;\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"points\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            forwardedRef,\n            pointsRef\n        ])\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferGeometry\", null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-position\",\n        count: positions.length / stride,\n        array: positions,\n        itemSize: stride,\n        usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n    }), colors && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-color\",\n        count: colors.length / stride,\n        array: colors,\n        itemSize: 3,\n        usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n    }), sizes && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"bufferAttribute\", {\n        attach: \"attributes-size\",\n        count: sizes.length / stride,\n        array: sizes,\n        itemSize: 1,\n        usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n    })), children);\n});\nconst Points = /* @__PURE__ */ /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, forwardedRef)=>{\n    if (props.positions instanceof Float32Array) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PointsBuffer, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n            ref: forwardedRef\n        }));\n    } else return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(PointsInstances, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({}, props, {\n        ref: forwardedRef\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Qb2ludHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNBO0FBQ3VCO0FBQ2I7QUFFekMsTUFBTU0saUJBQWlCLGFBQWEsR0FBRSxJQUFJTCwwQ0FBYTtBQUN2RCxNQUFNTyxPQUFPLGFBQWEsR0FBRSxJQUFJUCxzQ0FBUztBQUN6QyxNQUFNUyxVQUFVLGFBQWEsR0FBRSxJQUFJVCx5Q0FBWTtBQUMvQyxNQUFNVyxZQUFZLGFBQWEsR0FBRSxJQUFJWCwwQ0FBYTtBQUNsRCxNQUFNYSxzQkFBc0JiLHdDQUFXO0lBQ3JDZSxhQUFjO1FBQ1osS0FBSztRQUNMLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxLQUFLLEdBQUcsSUFBSWpCLHdDQUFXLENBQUM7UUFDN0IsSUFBSSxDQUFDbUIsUUFBUSxHQUFHO1lBQ2RDLFNBQVNDO1FBQ1g7UUFDQSxJQUFJLENBQUNDLFdBQVcsR0FBRztZQUNqQkYsU0FBU0M7UUFDWDtJQUNGO0lBRUEsbURBQW1EO0lBQ25ELElBQUlFLFdBQVc7UUFDYixJQUFJQztRQUNKLE9BQU8sQ0FBQ0Esd0JBQXdCLElBQUksQ0FBQ0wsUUFBUSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlJLHNCQUFzQkQsUUFBUTtJQUMxRztJQUNBRSxRQUFRQyxTQUFTLEVBQUVDLFVBQVUsRUFBRTtRQUM3QixJQUFJQyx1QkFBdUJDO1FBQzNCLE1BQU1DLFNBQVMsSUFBSSxDQUFDWCxRQUFRLENBQUNDLE9BQU87UUFDcEMsSUFBSSxDQUFDVSxVQUFVLENBQUNBLE9BQU9QLFFBQVEsRUFBRTtRQUNqQyxNQUFNUSxhQUFhRCxPQUFPRSxRQUFRLENBQUNDLFNBQVMsQ0FBQ0MsT0FBTyxDQUFDLElBQUksQ0FBQ1osV0FBVztRQUNyRSwyRUFBMkU7UUFDM0UsSUFBSVMsZUFBZSxDQUFDLEtBQUtBLGFBQWFELE9BQU9QLFFBQVEs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QUNoRThHLFFBQVE7UUFDUjNFLE9BQU9zRCxPQUFPSSxNQUFNLEdBQUc2QjtRQUN2QlgsT0FBT3RCO1FBQ1B1QixVQUFVO1FBQ1ZDLE9BQU9sSCxtREFBc0I7SUFDL0IsSUFBSTJGLFNBQVMsV0FBVyxHQUFFMUYsZ0RBQW1CLENBQUMsbUJBQW1CO1FBQy9EOEcsUUFBUTtRQUNSM0UsT0FBT3VELE1BQU1HLE1BQU0sR0FBRzZCO1FBQ3RCWCxPQUFPckI7UUFDUHNCLFVBQVU7UUFDVkMsT0FBT2xILG1EQUFzQjtJQUMvQixLQUFLK0U7QUFDUDtBQUNBLE1BQU14QyxTQUFTLGFBQWEsaUJBQUV0Qyw2Q0FBZ0IsQ0FBQyxDQUFDaUYsT0FBTzBDO0lBQ3JELElBQUkxQyxNQUFNTyxTQUFTLFlBQVlHLGNBQWM7UUFDM0MsT0FBTyxXQUFXLEdBQUUzRixnREFBbUIsQ0FBQ3lILGNBQWMzSCw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdtRixPQUFPO1lBQ3hFQyxLQUFLeUM7UUFDUDtJQUNGLE9BQU8sT0FBTyxXQUFXLEdBQUUzSCxnREFBbUIsQ0FBQzRFLGlCQUFpQjlFLDhFQUFRQSxDQUFDLENBQUMsR0FBR21GLE9BQU87UUFDbEZDLEtBQUt5QztJQUNQO0FBQ0Y7QUFFc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Qb2ludHMuanM/YzcyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBleHRlbmQsIHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCBtZXJnZVJlZnMgZnJvbSAncmVhY3QtbWVyZ2UtcmVmcyc7XG5cbmNvbnN0IF9pbnZlcnNlTWF0cml4ID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLk1hdHJpeDQoKTtcbmNvbnN0IF9yYXkgPSAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuUmF5KCk7XG5jb25zdCBfc3BoZXJlID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlNwaGVyZSgpO1xuY29uc3QgX3Bvc2l0aW9uID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlZlY3RvcjMoKTtcbmNsYXNzIFBvc2l0aW9uUG9pbnQgZXh0ZW5kcyBUSFJFRS5Hcm91cCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zaXplID0gMDtcbiAgICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCd3aGl0ZScpO1xuICAgIHRoaXMuaW5zdGFuY2UgPSB7XG4gICAgICBjdXJyZW50OiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuaW5zdGFuY2VLZXkgPSB7XG4gICAgICBjdXJyZW50OiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLy8gVGhpcyB3aWxsIGFsbG93IHRoZSB2aXJ0dWFsIGluc3RhbmNlIGhhdmUgYm91bmRzXG4gIGdldCBnZW9tZXRyeSgpIHtcbiAgICB2YXIgX3RoaXMkaW5zdGFuY2UkY3VycmVuO1xuICAgIHJldHVybiAoX3RoaXMkaW5zdGFuY2UkY3VycmVuID0gdGhpcy5pbnN0YW5jZS5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkaW5zdGFuY2UkY3VycmVuLmdlb21ldHJ5O1xuICB9XG4gIHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgdmFyIF9yYXljYXN0ZXIkcGFyYW1zJFBvaSwgX3JheWNhc3RlciRwYXJhbXMkUG9pMjtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmluc3RhbmNlLmN1cnJlbnQ7XG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5nZW9tZXRyeSkgcmV0dXJuO1xuICAgIGNvbnN0IGluc3RhbmNlSWQgPSBwYXJlbnQudXNlckRhdGEuaW5zdGFuY2VzLmluZGV4T2YodGhpcy5pbnN0YW5jZUtleSk7XG4gICAgLy8gSWYgdGhlIGluc3RhbmNlIHdhc24ndCBmb3VuZCBvciBleGNlZWRzIHRoZSBwYXJlbnRzIGRyYXcgcmFuZ2UsIGJhaWwgb3V0XG4gICAgaWYgKGluc3RhbmNlSWQgPT09IC0xIHx8IGluc3RhbmNlSWQgPiBwYXJlbnQuZ2VvbWV0cnkuZHJhd1JhbmdlLmNvdW50KSByZXR1cm47XG4gICAgY29uc3QgdGhyZXNob2xkID0gKF9yYXljYXN0ZXIkcGFyYW1zJFBvaSA9IChfcmF5Y2FzdGVyJHBhcmFtcyRQb2kyID0gcmF5Y2FzdGVyLnBhcmFtcy5Qb2ludHMpID09IG51bGwgPyB2b2lkIDAgOiBfcmF5Y2FzdGVyJHBhcmFtcyRQb2kyLnRocmVzaG9sZCkgIT09IG51bGwgJiYgX3JheWNhc3RlciRwYXJhbXMkUG9pICE9PSB2b2lkIDAgPyBfcmF5Y2FzdGVyJHBhcmFtcyRQb2kgOiAxO1xuICAgIF9zcGhlcmUuc2V0KHRoaXMuZ2V0V29ybGRQb3NpdGlvbihfcG9zaXRpb24pLCB0aHJlc2hvbGQpO1xuICAgIGlmIChyYXljYXN0ZXIucmF5LmludGVyc2VjdHNTcGhlcmUoX3NwaGVyZSkgPT09IGZhbHNlKSByZXR1cm47XG4gICAgX2ludmVyc2VNYXRyaXguY29weShwYXJlbnQubWF0cml4V29ybGQpLmludmVydCgpO1xuICAgIF9yYXkuY29weShyYXljYXN0ZXIucmF5KS5hcHBseU1hdHJpeDQoX2ludmVyc2VNYXRyaXgpO1xuICAgIGNvbnN0IGxvY2FsVGhyZXNob2xkID0gdGhyZXNob2xkIC8gKCh0aGlzLnNjYWxlLnggKyB0aGlzLnNjYWxlLnkgKyB0aGlzLnNjYWxlLnopIC8gMyk7XG4gICAgY29uc3QgbG9jYWxUaHJlc2hvbGRTcSA9IGxvY2FsVGhyZXNob2xkICogbG9jYWxUaHJlc2hvbGQ7XG4gICAgY29uc3QgcmF5UG9pbnREaXN0YW5jZVNxID0gX3JheS5kaXN0YW5jZVNxVG9Qb2ludCh0aGlzLnBvc2l0aW9uKTtcbiAgICBpZiAocmF5UG9pbnREaXN0YW5jZVNxIDwgbG9jYWxUaHJlc2hvbGRTcSkge1xuICAgICAgY29uc3QgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgX3JheS5jbG9zZXN0UG9pbnRUb1BvaW50KHRoaXMucG9zaXRpb24sIGludGVyc2VjdFBvaW50KTtcbiAgICAgIGludGVyc2VjdFBvaW50LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyhpbnRlcnNlY3RQb2ludCk7XG4gICAgICBpZiAoZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIpIHJldHVybjtcbiAgICAgIGludGVyc2VjdHMucHVzaCh7XG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KHJheVBvaW50RGlzdGFuY2VTcSksXG4gICAgICAgIHBvaW50OiBpbnRlcnNlY3RQb2ludCxcbiAgICAgICAgaW5kZXg6IGluc3RhbmNlSWQsXG4gICAgICAgIGZhY2U6IG51bGwsXG4gICAgICAgIG9iamVjdDogdGhpc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5sZXQgaSwgcG9zaXRpb25SZWY7XG5jb25zdCBjb250ZXh0ID0gLyogQF9fUFVSRV9fICovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHBhcmVudE1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5NYXRyaXg0KCk7XG5jb25zdCBwb3NpdGlvbiA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbi8qKlxuICogSW5zdGFuY2UgaW1wbGVtZW50YXRpb24sIHJlbGllcyBvbiByZWFjdCArIGNvbnRleHQgdG8gdXBkYXRlIHRoZSBhdHRyaWJ1dGVzIGJhc2VkIG9uIHRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudFxuICovXG5jb25zdCBQb2ludHNJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGNoaWxkcmVuLFxuICByYW5nZSxcbiAgbGltaXQgPSAxMDAwLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHBhcmVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW3JlZnMsIHNldFJlZnNdID0gUmVhY3QudXNlU3RhdGUoW10pO1xuICBjb25zdCBbW3Bvc2l0aW9ucywgY29sb3JzLCBzaXplc11dID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gW25ldyBGbG9hdDMyQXJyYXkobGltaXQgKiAzKSwgRmxvYXQzMkFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogbGltaXQgKiAzXG4gIH0sICgpID0+IDEpLCBGbG9hdDMyQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBsaW1pdFxuICB9LCAoKSA9PiAxKV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFdlIG1pZ2h0IGJlIGEgZnJhbWUgdG9vIGxhdGU/IPCfpLfigI3imYLvuI9cbiAgICBwYXJlbnRSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfSk7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBwYXJlbnRSZWYuY3VycmVudC51cGRhdGVNYXRyaXgoKTtcbiAgICBwYXJlbnRSZWYuY3VycmVudC51cGRhdGVNYXRyaXhXb3JsZCgpO1xuICAgIHBhcmVudE1hdHJpeC5jb3B5KHBhcmVudFJlZi5jdXJyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICBwYXJlbnRSZWYuY3VycmVudC5nZW9tZXRyeS5kcmF3UmFuZ2UuY291bnQgPSBNYXRoLm1pbihsaW1pdCwgcmFuZ2UgIT09IHVuZGVmaW5lZCA/IHJhbmdlIDogbGltaXQsIHJlZnMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9zaXRpb25SZWYgPSByZWZzW2ldLmN1cnJlbnQ7XG4gICAgICBwb3NpdGlvblJlZi5nZXRXb3JsZFBvc2l0aW9uKHBvc2l0aW9uKS5hcHBseU1hdHJpeDQocGFyZW50TWF0cml4KTtcbiAgICAgIHBvc2l0aW9uLnRvQXJyYXkocG9zaXRpb25zLCBpICogMyk7XG4gICAgICBwYXJlbnRSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIHBvc2l0aW9uUmVmLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgcG9zaXRpb25SZWYuY29sb3IudG9BcnJheShjb2xvcnMsIGkgKiAzKTtcbiAgICAgIHBhcmVudFJlZi5jdXJyZW50Lmdlb21ldHJ5LmF0dHJpYnV0ZXMuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgc2l6ZXMuc2V0KFtwb3NpdGlvblJlZi5zaXplXSwgaSk7XG4gICAgICBwYXJlbnRSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnNpemUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGFwaSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBnZXRQYXJlbnQ6ICgpID0+IHBhcmVudFJlZixcbiAgICBzdWJzY3JpYmU6IHJlZiA9PiB7XG4gICAgICBzZXRSZWZzKHJlZnMgPT4gWy4uLnJlZnMsIHJlZl0pO1xuICAgICAgcmV0dXJuICgpID0+IHNldFJlZnMocmVmcyA9PiByZWZzLmZpbHRlcihpdGVtID0+IGl0ZW0uY3VycmVudCAhPT0gcmVmLmN1cnJlbnQpKTtcbiAgICB9XG4gIH0pLCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBvaW50c1wiLCBfZXh0ZW5kcyh7XG4gICAgdXNlckRhdGE6IHtcbiAgICAgIGluc3RhbmNlczogcmVmc1xuICAgIH0sXG4gICAgbWF0cml4QXV0b1VwZGF0ZTogZmFsc2UsXG4gICAgcmVmOiBtZXJnZVJlZnMoW3JlZiwgcGFyZW50UmVmXSksXG4gICAgcmF5Y2FzdDogKCkgPT4gbnVsbFxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyR2VvbWV0cnlcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidWZmZXJBdHRyaWJ1dGVcIiwge1xuICAgIGF0dGFjaDogXCJhdHRyaWJ1dGVzLXBvc2l0aW9uXCIsXG4gICAgY291bnQ6IHBvc2l0aW9ucy5sZW5ndGggLyAzLFxuICAgIGFycmF5OiBwb3NpdGlvbnMsXG4gICAgaXRlbVNpemU6IDMsXG4gICAgdXNhZ2U6IFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2VcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1jb2xvclwiLFxuICAgIGNvdW50OiBjb2xvcnMubGVuZ3RoIC8gMyxcbiAgICBhcnJheTogY29sb3JzLFxuICAgIGl0ZW1TaXplOiAzLFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImF0dHJpYnV0ZXMtc2l6ZVwiLFxuICAgIGNvdW50OiBzaXplcy5sZW5ndGgsXG4gICAgYXJyYXk6IHNpemVzLFxuICAgIGl0ZW1TaXplOiAxLFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoY29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcGlcbiAgfSwgY2hpbGRyZW4pKTtcbn0pO1xuY29uc3QgUG9pbnQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGNoaWxkcmVuLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBQb3NpdGlvblBvaW50XG4gIH0pLCBbXSk7XG4gIGNvbnN0IGdyb3VwID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHtcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0UGFyZW50XG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gc3Vic2NyaWJlKGdyb3VwKSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwb3NpdGlvblBvaW50XCIsIF9leHRlbmRzKHtcbiAgICBpbnN0YW5jZTogZ2V0UGFyZW50KCksXG4gICAgaW5zdGFuY2VLZXk6IGdyb3VwLFxuICAgIHJlZjogbWVyZ2VSZWZzKFtyZWYsIGdyb3VwXSlcbiAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG59KTtcblxuLyoqXG4gKiBCdWZmZXIgaW1wbGVtZW50YXRpb24sIHJlbGllcyBvbiBjb21wbGV0ZSBidWZmZXJzIG9mIHRoZSBjb3JyZWN0IG51bWJlciwgbGVhdmVzIGl0IHRvIHRoZSB1c2VyIHRvIHVwZGF0ZSB0aGVtXG4gKi9cblxuY29uc3QgUG9pbnRzQnVmZmVyID0gLyogQF9fUFVSRV9fICovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBjaGlsZHJlbixcbiAgcG9zaXRpb25zLFxuICBjb2xvcnMsXG4gIHNpemVzLFxuICBzdHJpZGUgPSAzLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHBvaW50c1JlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSBwb2ludHNSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIGF0dHIucG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGlmIChjb2xvcnMpIGF0dHIuY29sb3IubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIGlmIChzaXplcykgYXR0ci5zaXplLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBvaW50c1wiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBtZXJnZVJlZnMoW2ZvcndhcmRlZFJlZiwgcG9pbnRzUmVmXSlcbiAgfSwgcHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1ZmZlckdlb21ldHJ5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1wb3NpdGlvblwiLFxuICAgIGNvdW50OiBwb3NpdGlvbnMubGVuZ3RoIC8gc3RyaWRlLFxuICAgIGFycmF5OiBwb3NpdGlvbnMsXG4gICAgaXRlbVNpemU6IHN0cmlkZSxcbiAgICB1c2FnZTogVEhSRUUuRHluYW1pY0RyYXdVc2FnZVxuICB9KSwgY29sb3JzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1jb2xvclwiLFxuICAgIGNvdW50OiBjb2xvcnMubGVuZ3RoIC8gc3RyaWRlLFxuICAgIGFycmF5OiBjb2xvcnMsXG4gICAgaXRlbVNpemU6IDMsXG4gICAgdXNhZ2U6IFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2VcbiAgfSksIHNpemVzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICBhdHRhY2g6IFwiYXR0cmlidXRlcy1zaXplXCIsXG4gICAgY291bnQ6IHNpemVzLmxlbmd0aCAvIHN0cmlkZSxcbiAgICBhcnJheTogc2l6ZXMsXG4gICAgaXRlbVNpemU6IDEsXG4gICAgdXNhZ2U6IFRIUkVFLkR5bmFtaWNEcmF3VXNhZ2VcbiAgfSkpLCBjaGlsZHJlbik7XG59KTtcbmNvbnN0IFBvaW50cyA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgaWYgKHByb3BzLnBvc2l0aW9ucyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb2ludHNCdWZmZXIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcmVmOiBmb3J3YXJkZWRSZWZcbiAgICB9KSk7XG4gIH0gZWxzZSByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUG9pbnRzSW5zdGFuY2VzLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IGZvcndhcmRlZFJlZlxuICB9KSk7XG59KTtcblxuZXhwb3J0IHsgUG9pbnQsIFBvaW50cywgUG9pbnRzQnVmZmVyLCBQb3NpdGlvblBvaW50IH07XG4iXSwibmFtZXMiOlsiX2V4dGVuZHMiLCJUSFJFRSIsIlJlYWN0IiwiZXh0ZW5kIiwidXNlRnJhbWUiLCJtZXJnZVJlZnMiLCJfaW52ZXJzZU1hdHJpeCIsIk1hdHJpeDQiLCJfcmF5IiwiUmF5IiwiX3NwaGVyZSIsIlNwaGVyZSIsIl9wb3NpdGlvbiIsIlZlY3RvcjMiLCJQb3NpdGlvblBvaW50IiwiR3JvdXAiLCJjb25zdHJ1Y3RvciIsInNpemUiLCJjb2xvciIsIkNvbG9yIiwiaW5zdGFuY2UiLCJjdXJyZW50IiwidW5kZWZpbmVkIiwiaW5zdGFuY2VLZXkiLCJnZW9tZXRyeSIsIl90aGlzJGluc3RhbmNlJGN1cnJlbiIsInJheWNhc3QiLCJyYXljYXN0ZXIiLCJpbnRlcnNlY3RzIiwiX3JheWNhc3RlciRwYXJhbXMkUG9pIiwiX3JheWNhc3RlciRwYXJhbXMkUG9pMiIsInBhcmVudCIsImluc3RhbmNlSWQiLCJ1c2VyRGF0YSIsImluc3RhbmNlcyIsImluZGV4T2YiLCJkcmF3UmFuZ2UiLCJjb3VudCIsInRocmVzaG9sZCIsInBhcmFtcyIsIlBvaW50cyIsInNldCIsImdldFdvcmxkUG9zaXRpb24iLCJyYXkiLCJpbnRlcnNlY3RzU3BoZXJlIiwiY29weSIsIm1hdHJpeFdvcmxkIiwiaW52ZXJ0IiwiYXBwbHlNYXRyaXg0IiwibG9jYWxUaHJlc2hvbGQiLCJzY2FsZSIsIngiLCJ5IiwieiIsImxvY2FsVGhyZXNob2xkU3EiLCJyYXlQb2ludERpc3RhbmNlU3EiLCJkaXN0YW5jZVNxVG9Qb2ludCIsInBvc2l0aW9uIiwiaW50ZXJzZWN0UG9pbnQiLCJjbG9zZXN0UG9pbnRUb1BvaW50IiwiZGlzdGFuY2UiLCJvcmlnaW4iLCJkaXN0YW5jZVRvIiwibmVhciIsImZhciIsInB1c2giLCJkaXN0YW5jZVRvUmF5IiwiTWF0aCIsInNxcnQiLCJwb2ludCIsImluZGV4IiwiZmFjZSIsIm9iamVjdCIsImkiLCJwb3NpdGlvblJlZiIsImNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwicGFyZW50TWF0cml4IiwiUG9pbnRzSW5zdGFuY2VzIiwiZm9yd2FyZFJlZiIsImNoaWxkcmVuIiwicmFuZ2UiLCJsaW1pdCIsInByb3BzIiwicmVmIiwicGFyZW50UmVmIiwidXNlUmVmIiwicmVmcyIsInNldFJlZnMiLCJ1c2VTdGF0ZSIsInBvc2l0aW9ucyIsImNvbG9ycyIsInNpemVzIiwiRmxvYXQzMkFycmF5IiwiZnJvbSIsImxlbmd0aCIsInVzZUVmZmVjdCIsImF0dHJpYnV0ZXMiLCJuZWVkc1VwZGF0ZSIsInVwZGF0ZU1hdHJpeCIsInVwZGF0ZU1hdHJpeFdvcmxkIiwibWluIiwidG9BcnJheSIsIm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUiLCJhcGkiLCJ1c2VNZW1vIiwiZ2V0UGFyZW50Iiwic3Vic2NyaWJlIiwiZmlsdGVyIiwiaXRlbSIsImNyZWF0ZUVsZW1lbnQiLCJtYXRyaXhBdXRvVXBkYXRlIiwiYXR0YWNoIiwiYXJyYXkiLCJpdGVtU2l6ZSIsInVzYWdlIiwiRHluYW1pY0RyYXdVc2FnZSIsIlByb3ZpZGVyIiwidmFsdWUiLCJQb2ludCIsImdyb3VwIiwidXNlQ29udGV4dCIsInVzZUxheW91dEVmZmVjdCIsIlBvaW50c0J1ZmZlciIsInN0cmlkZSIsImZvcndhcmRlZFJlZiIsInBvaW50c1JlZiIsImF0dHIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Points.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/helpers/constants.js":
/*!*************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n\nconst getVersion = ()=>parseInt(three__WEBPACK_IMPORTED_MODULE_0__.REVISION.replace(/\\D+/g, \"\"));\nconst version = /* @__PURE__ */ getVersion();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUM7QUFFakMsTUFBTUMsYUFBYSxJQUFNQyxTQUFTRiwyQ0FBUUEsQ0FBQ0csT0FBTyxDQUFDLFFBQVE7QUFDM0QsTUFBTUMsVUFBVSxhQUFhLEdBQUVIO0FBRVoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvaGVscGVycy9jb25zdGFudHMuanM/NTA5NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSRVZJU0lPTiB9IGZyb20gJ3RocmVlJztcblxuY29uc3QgZ2V0VmVyc2lvbiA9ICgpID0+IHBhcnNlSW50KFJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgJycpKTtcbmNvbnN0IHZlcnNpb24gPSAvKiBAX19QVVJFX18gKi9nZXRWZXJzaW9uKCk7XG5cbmV4cG9ydCB7IHZlcnNpb24gfTtcbiJdLCJuYW1lcyI6WyJSRVZJU0lPTiIsImdldFZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiLCJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/helpers/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-710fb441.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-710fb441.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useThree),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useFrame),\n/* harmony export */   D: () => (/* binding */ useGraph),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   F: () => (/* binding */ useLoader),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ context),\n/* harmony export */   g: () => (/* binding */ createPortal),\n/* harmony export */   h: () => (/* binding */ reconciler),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ applyProps),\n/* harmony export */   k: () => (/* binding */ dispose),\n/* harmony export */   l: () => (/* binding */ invalidate),\n/* harmony export */   m: () => (/* binding */ advance),\n/* harmony export */   n: () => (/* binding */ addEffect),\n/* harmony export */   o: () => (/* binding */ addAfterEffect),\n/* harmony export */   p: () => (/* binding */ addTail),\n/* harmony export */   q: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ act),\n/* harmony export */   w: () => (/* binding */ buildGraph),\n/* harmony export */   x: () => (/* binding */ roots),\n/* harmony export */   y: () => (/* binding */ useInstanceHandle),\n/* harmony export */   z: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/zustand/esm/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.Material) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // Remove interactivity\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(child.__r3f.root, child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = !isPrimitive && (dispose === undefined ? child.dispose !== null : dispose);\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                const callback = ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                };\n                // Schedule async at runtime, flush sync in testing\n                if (typeof IS_REACT_ACT_ENVIRONMENT === \"undefined\") {\n                    (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, callback);\n                } else {\n                    callback();\n                }\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = newInstance.__r3f.root.getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, warn on undefined behavior\n    const handleTextInstance = ()=>console.warn(\"Text is not allowed in the R3F tree! This could be stray whitespace or characters.\");\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                instance.__r3f.root.getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-ignore\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\n * The current THREE.ColorManagement instance, if present.\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\n * Returns instance root state\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n/**\n * Collects nodes and materials from a THREE.Object3D.\n */ function buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    var _instance$__r3f;\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f2;\n        // Bail out on primitive object\n        if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\nconst __DEV__ = typeof process !== \"undefined\" && \"development\" !== \"production\";\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f3, _root$getState, _instance$__r3f4;\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f3 = instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-ignore\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && // Some environments may break strict identity checks by duplicating versions of three.js.\n            // Loosen to unminified names, ignoring descendents.\n            // https://github.com/pmndrs/react-three-fiber/issues/2856\n            // TODO: fix upstream and remove in v9\n            (__DEV__ ? targetProp.constructor.name === value.constructor.name : targetProp.constructor === value.constructor)) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Color;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_4__.Texture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState.parent && rootState.internal && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Pre-emptively remove the instance from the interaction manager\n        const index = rootState.internal.interaction.indexOf(instance);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) rootState.internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\n        MAYBE TODO, DELETE IF NOT: \n          Check if the object is captured, captured events should not have intersects running in parallel\n          But wouldn't it be better to just replace capturedMap with a single entry?\n          Also, are we OK with straight up making picking up multiple objects impossible?\n          \n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \n        if (pointerId !== undefined) {\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\n          if (capturedMeshSet) {\n            const captured = capturedMeshSet.get(eventObject)\n            if (captured && captured.localState.stopped) return\n          }\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target instanceof three__WEBPACK_IMPORTED_MODULE_4__.Vector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_4__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size.width !== oldSize.width || size.height !== oldSize.height || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState()), frames);\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        /**\n     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n     */ invalidate,\n        /**\n     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n     */ advance\n    };\n}\n/**\n * Exposes an object's {@link LocalState}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nconst memoizedLoaders = new WeakMap();\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        let loader = memoizedLoaders.get(Proto);\n        if (!loader) {\n            loader = new Proto();\n            memoizedLoaders.set(Proto, loader);\n        }\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error == null ? void 0 : error.message}`)))))).finally(()=>loader.dispose == null ? void 0 : loader.dispose());\n    };\n}\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\n * Preloads an asset into cache as a side-effect.\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\n * Removes a loaded asset from cache.\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_4__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    const defaultStyle = typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement;\n    if (defaultSize) {\n        const { width, height, top, left, updateStyle = defaultStyle } = defaultSize;\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle\n        };\n    } else if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left,\n            updateStyle: defaultStyle\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0,\n            updateStyle: defaultStyle\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) applyProps(camera, cameraOptions);\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n                // Configure raycaster\n                // https://github.com/pmndrs/react-xr/issues/300\n                raycaster.camera = camera;\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Scene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_4__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_4__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_4__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            // Set color space and tonemapping preferences\n            const LinearEncoding = 3000;\n            const sRGBEncoding = 3001;\n            applyProps(gl, {\n                outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_4__.ACESFilmicToneMapping\n            });\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: store\n    }, children);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portal, {\n        key: container.uuid,\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n   *  <Canvas>\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n            usePortalStore.destroy();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        inject\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, reconciler.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: usePortalStore\n    }, children), usePortalStore, null));\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtNzEwZmI0NDEuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDYTtBQUNtQztBQUNyQjtBQUV4RCxJQUFJYSxhQUFhLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQzFDQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxZQUFZLENBQUM7QUFDbkIsTUFBTUMsU0FBU0MsQ0FBQUEsVUFBVyxLQUFLTCxPQUFPTSxNQUFNLENBQUNILFdBQVdFO0FBQ3hELFNBQVNFLGVBQWVDLE1BQU0sRUFBRUMsaUJBQWlCO0lBQy9DLFNBQVNDLGVBQWVDLElBQUksRUFBRSxFQUM1QkMsT0FBTyxFQUFFLEVBQ1RDLE1BQU0sRUFDTixHQUFHQyxPQUNKLEVBQUVDLElBQUk7UUFDTCxJQUFJQyxPQUFPLENBQUMsRUFBRUwsSUFBSSxDQUFDLEVBQUUsQ0FBQ00sV0FBVyxHQUFHLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDckQsSUFBSUM7UUFDSixJQUFJUixTQUFTLGFBQWE7WUFDeEIsSUFBSUcsTUFBTU0sTUFBTSxLQUFLQyxXQUFXLE1BQU0sSUFBSUMsTUFBTTtZQUNoRCxNQUFNRixTQUFTTixNQUFNTSxNQUFNO1lBQzNCRCxXQUFXSSxRQUFRSCxRQUFRO2dCQUN6QlQ7Z0JBQ0FJO2dCQUNBRjtnQkFDQVcsV0FBVztZQUNiO1FBQ0YsT0FBTztZQUNMLE1BQU1DLFNBQVN0QixTQUFTLENBQUNhLEtBQUs7WUFDOUIsSUFBSSxDQUFDUyxRQUFRO2dCQUNYLE1BQU0sSUFBSUgsTUFBTSxDQUFDLEtBQUssRUFBRU4sS0FBSyw0SkFBNEosQ0FBQztZQUM1TDtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNVLE1BQU1DLE9BQU8sQ0FBQ2YsT0FBTyxNQUFNLElBQUlVLE1B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QVcsR0FBRXZtQixnREFBbUIsQ0FBQ3VhLFFBQVFxTCxRQUFRLEVBQUU7UUFDeElsZCxPQUFPb2U7SUFDVCxHQUFHOWlCLFdBQVc4aUIsZ0JBQWdCO0FBQ2hDO0FBQ0FuZ0IsV0FBVzBnQixrQkFBa0IsQ0FBQztJQUM1QkMsWUFBWXZXLE1BQXlCLEdBQWUsQ0FBQyxHQUFHO0lBQ3hEd1cscUJBQXFCO0lBQ3JCQyxTQUFTeG5CLDBDQUFhO0FBQ3hCO0FBQ0EsTUFBTXluQixNQUFNem5CLCtDQUFrQjtBQUV1aEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcGFjZS1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtNzEwZmI0NDEuZXNtLmpzPzUyNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgRGVmYXVsdEV2ZW50UHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5LCBEaXNjcmV0ZUV2ZW50UHJpb3JpdHksIENvbmN1cnJlbnRSb290IH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0IGNyZWF0ZSBmcm9tICd6dXN0YW5kJztcbmltcG9ydCBSZWNvbmNpbGVyIGZyb20gJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0IHsgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaywgdW5zdGFibGVfSWRsZVByaW9yaXR5IH0gZnJvbSAnc2NoZWR1bGVyJztcbmltcG9ydCB7IHN1c3BlbmQsIHByZWxvYWQsIGNsZWFyIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5cbnZhciB0aHJlZVR5cGVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGxcbn0pO1xuXG5jb25zdCBjYXRhbG9ndWUgPSB7fTtcbmNvbnN0IGV4dGVuZCA9IG9iamVjdHMgPT4gdm9pZCBPYmplY3QuYXNzaWduKGNhdGFsb2d1ZSwgb2JqZWN0cyk7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlcihfcm9vdHMsIF9nZXRFdmVudFByaW9yaXR5KSB7XG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKHR5cGUsIHtcbiAgICBhcmdzID0gW10sXG4gICAgYXR0YWNoLFxuICAgIC4uLnByb3BzXG4gIH0sIHJvb3QpIHtcbiAgICBsZXQgbmFtZSA9IGAke3R5cGVbMF0udG9VcHBlckNhc2UoKX0ke3R5cGUuc2xpY2UoMSl9YDtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKHR5cGUgPT09ICdwcmltaXRpdmUnKSB7XG4gICAgICBpZiAocHJvcHMub2JqZWN0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlIzRjogUHJpbWl0aXZlcyB3aXRob3V0ICdvYmplY3QnIGFyZSBpbnZhbGlkIVwiKTtcbiAgICAgIGNvbnN0IG9iamVjdCA9IHByb3BzLm9iamVjdDtcbiAgICAgIGluc3RhbmNlID0gcHJlcGFyZShvYmplY3QsIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICBwcmltaXRpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBjYXRhbG9ndWVbbmFtZV07XG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFIzRjogJHtuYW1lfSBpcyBub3QgcGFydCBvZiB0aGUgVEhSRUUgbmFtZXNwYWNlISBEaWQgeW91IGZvcmdldCB0byBleHRlbmQ/IFNlZTogaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL29iamVjdHMjdXNpbmctM3JkLXBhcnR5LW9iamVjdHMtZGVjbGFyYXRpdmVseWApO1xuICAgICAgfVxuXG4gICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncykpIHRocm93IG5ldyBFcnJvcignUjNGOiBUaGUgYXJncyBwcm9wIG11c3QgYmUgYW4gYXJyYXkhJyk7XG5cbiAgICAgIC8vIEluc3RhbmNpYXRlIG5ldyBvYmplY3QsIGxpbmsgaXQgdG8gdGhlIHJvb3RcbiAgICAgIC8vIEFwcGVuZCBtZW1vaXplZCBwcm9wcyB3aXRoIGFyZ3Mgc28gaXQncyBub3QgZm9yZ290dGVuXG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUobmV3IHRhcmdldCguLi5hcmdzKSwge1xuICAgICAgICB0eXBlLFxuICAgICAgICByb290LFxuICAgICAgICBhdHRhY2gsXG4gICAgICAgIC8vIFNhdmUgYXJncyBpbiBjYXNlIHdlIG5lZWQgdG8gcmVjb25zdHJ1Y3QgbGF0ZXIgZm9yIEhNUlxuICAgICAgICBtZW1vaXplZFByb3BzOiB7XG4gICAgICAgICAgYXJnc1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBdXRvLWF0dGFjaCBnZW9tZXRyaWVzIGFuZCBtYXRlcmlhbHNcbiAgICBpZiAoaW5zdGFuY2UuX19yM2YuYXR0YWNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5KSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnZ2VvbWV0cnknO2Vsc2UgaWYgKGluc3RhbmNlIGluc3RhbmNlb2YgVEhSRUUuTWF0ZXJpYWwpIGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9ICdtYXRlcmlhbCc7XG4gICAgfVxuXG4gICAgLy8gSXQgc2hvdWxkIE5PVCBjYWxsIG9uVXBkYXRlIG9uIG9iamVjdCBpbnN0YW5jaWF0aW9uLCBiZWNhdXNlIGl0IGhhc24ndCBiZWVuIGFkZGVkIHRvIHRoZVxuICAgIC8vIHZpZXcgeWV0LiBJZiB0aGUgY2FsbGJhY2sgcmVsaWVzIG9uIHJlZmVyZW5jZXMgZm9yIGluc3RhbmNlLCB0aGV5IHdvbid0IGJlIHJlYWR5IHlldCwgdGhpcyBpc1xuICAgIC8vIHdoeSBpdCBwYXNzZXMgXCJ0cnVlXCIgaGVyZVxuICAgIC8vIFRoZXJlIGlzIG5vIHJlYXNvbiB0byBhcHBseSBwcm9wcyB0byBpbmplY3RzXG4gICAgaWYgKG5hbWUgIT09ICdpbmplY3QnKSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIHByb3BzKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmLCBfcGFyZW50SW5zdGFuY2UkX19yM2Y7XG4gICAgICAvLyBUaGUgYXR0YWNoIGF0dHJpYnV0ZSBpbXBsaWVzIHRoYXQgdGhlIG9iamVjdCBhdHRhY2hlcyBpdHNlbGYgb24gdGhlIHBhcmVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICAvLyBhZGQgaW4gdGhlIHVzdWFsIHBhcmVudC1jaGlsZCB3YXlcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuYWRkKGNoaWxkKTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBpcyBmb3IgYW55dGhpbmcgdGhhdCB1c2VkIGF0dGFjaCwgYW5kIGZvciBub24tT2JqZWN0M0RzIHRoYXQgZG9uJ3QgZ2V0IGF0dGFjaGVkIHRvIHByb3BzO1xuICAgICAgLy8gdGhhdCBpcywgYW55dGhpbmcgdGhhdCdzIGEgY2hpbGQgaW4gUmVhY3QgYnV0IG5vdCBhIGNoaWxkIGluIHRoZSBzY2VuZWdyYXBoLlxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmLm9iamVjdHMucHVzaChjaGlsZCk7XG4gICAgICBpZiAoIWNoaWxkLl9fcjNmKSBwcmVwYXJlKGNoaWxkLCB7fSk7XG4gICAgICBjaGlsZC5fX3IzZi5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgIHVwZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGluc2VydEJlZm9yZShwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICB2YXIgX2NoaWxkJF9fcjNmMiwgX3BhcmVudEluc3RhbmNlJF9fcjNmMjtcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjIuYXR0YWNoKSB7XG4gICAgICAgIGF0dGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBwYXJlbnRJbnN0YW5jZTtcbiAgICAgICAgY2hpbGQuZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgdHlwZTogJ2FkZGVkJ1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVzdFNpYmxpbmdzID0gcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKHNpYmxpbmcgPT4gc2libGluZyAhPT0gY2hpbGQpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJlc3RTaWJsaW5ncy5pbmRleE9mKGJlZm9yZUNoaWxkKTtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UuY2hpbGRyZW4gPSBbLi4ucmVzdFNpYmxpbmdzLnNsaWNlKDAsIGluZGV4KSwgY2hpbGQsIC4uLnJlc3RTaWJsaW5ncy5zbGljZShpbmRleCldO1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWFkZGVkKSAoX3BhcmVudEluc3RhbmNlJF9fcjNmMiA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmVudEluc3RhbmNlJF9fcjNmMi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoYXJyYXksIHBhcmVudCwgZGlzcG9zZSA9IGZhbHNlKSB7XG4gICAgaWYgKGFycmF5KSBbLi4uYXJyYXldLmZvckVhY2goY2hpbGQgPT4gcmVtb3ZlQ2hpbGQocGFyZW50LCBjaGlsZCwgZGlzcG9zZSkpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgZGlzcG9zZSkge1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMsIF9jaGlsZCRfX3IzZjMsIF9jaGlsZCRfX3IzZjU7XG4gICAgICAvLyBDbGVhciB0aGUgcGFyZW50IHJlZmVyZW5jZVxuICAgICAgaWYgKGNoaWxkLl9fcjNmKSBjaGlsZC5fX3IzZi5wYXJlbnQgPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIGNoaWxkIGZyb20gdGhlIHBhcmVudHMgb2JqZWN0c1xuICAgICAgaWYgKChfcGFyZW50SW5zdGFuY2UkX19yM2YzID0gcGFyZW50SW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX3BhcmVudEluc3RhbmNlJF9fcjNmMy5vYmplY3RzKSBwYXJlbnRJbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cy5maWx0ZXIoeCA9PiB4ICE9PSBjaGlsZCk7XG4gICAgICAvLyBSZW1vdmUgYXR0YWNobWVudFxuICAgICAgaWYgKChfY2hpbGQkX19yM2YzID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmMy5hdHRhY2gpIHtcbiAgICAgICAgZGV0YWNoKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgY2hpbGQuX19yM2YuYXR0YWNoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQuaXNPYmplY3QzRCAmJiBwYXJlbnRJbnN0YW5jZS5pc09iamVjdDNEKSB7XG4gICAgICAgIHZhciBfY2hpbGQkX19yM2Y0O1xuICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmUoY2hpbGQpO1xuICAgICAgICAvLyBSZW1vdmUgaW50ZXJhY3Rpdml0eVxuICAgICAgICBpZiAoKF9jaGlsZCRfX3IzZjQgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2Y0LnJvb3QpIHtcbiAgICAgICAgICByZW1vdmVJbnRlcmFjdGl2aXR5KGNoaWxkLl9fcjNmLnJvb3QsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyBvYmplY3RzIHRvIGJhaWwgb3V0IG9mIHJlY3Vyc2l2ZSBkaXNwb3NlIGFsdG9nZXRoZXIgYnkgcGFzc2luZyBkaXNwb3NlPXtudWxsfVxuICAgICAgLy8gTmV2ZXIgZGlzcG9zZSBvZiBwcmltaXRpdmVzIGJlY2F1c2UgdGhlaXIgc3RhdGUgbWF5IGJlIGtlcHQgb3V0c2lkZSBvZiBSZWFjdCFcbiAgICAgIC8vIEluIG9yZGVyIGZvciBhbiBvYmplY3QgdG8gYmUgYWJsZSB0byBkaXNwb3NlIGl0IGhhcyB0byBoYXZlXG4gICAgICAvLyAgIC0gYSBkaXNwb3NlIG1ldGhvZCxcbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSAvPlxuICAgICAgLy8gICAtIGl0IGNhbm5vdCBiZSBhIFRIUkVFLlNjZW5lLCBiZWNhdXNlIHRocmVlIGhhcyBicm9rZW4gaXQncyBvd24gYXBpXG4gICAgICAvL1xuICAgICAgLy8gU2luY2UgZGlzcG9zYWwgaXMgcmVjdXJzaXZlLCB3ZSBjYW4gY2hlY2sgdGhlIG9wdGlvbmFsIGRpc3Bvc2UgYXJnLCB3aGljaCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgICAgLy8gd2hlbiB0aGUgcmVjb25jaWxlciBjYWxscyBpdCwgYnV0IHRoZW4gY2Fycnkgb3VyIG93biBjaGVjayByZWN1cnNpdmVseVxuICAgICAgY29uc3QgaXNQcmltaXRpdmUgPSAoX2NoaWxkJF9fcjNmNSA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmNS5wcmltaXRpdmU7XG4gICAgICBjb25zdCBzaG91bGREaXNwb3NlID0gIWlzUHJpbWl0aXZlICYmIChkaXNwb3NlID09PSB1bmRlZmluZWQgPyBjaGlsZC5kaXNwb3NlICE9PSBudWxsIDogZGlzcG9zZSk7XG5cbiAgICAgIC8vIFJlbW92ZSBuZXN0ZWQgY2hpbGQgb2JqZWN0cy4gUHJpbWl0aXZlcyBzaG91bGQgbm90IGhhdmUgb2JqZWN0cyBhbmQgY2hpbGRyZW4gdGhhdCBhcmVcbiAgICAgIC8vIGF0dGFjaGVkIHRvIHRoZW0gZGVjbGFyYXRpdmVseSAuLi5cbiAgICAgIGlmICghaXNQcmltaXRpdmUpIHtcbiAgICAgICAgdmFyIF9jaGlsZCRfX3IzZjY7XG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZSgoX2NoaWxkJF9fcjNmNiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmNi5vYmplY3RzLCBjaGlsZCwgc2hvdWxkRGlzcG9zZSk7XG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShjaGlsZC5jaGlsZHJlbiwgY2hpbGQsIHNob3VsZERpc3Bvc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlc1xuICAgICAgZGVsZXRlIGNoaWxkLl9fcjNmO1xuXG4gICAgICAvLyBEaXNwb3NlIGl0ZW0gd2hlbmV2ZXIgdGhlIHJlY29uY2lsZXIgZmVlbHMgbGlrZSBpdFxuICAgICAgaWYgKHNob3VsZERpc3Bvc2UgJiYgY2hpbGQuZGlzcG9zZSAmJiBjaGlsZC50eXBlICE9PSAnU2NlbmUnKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjaGlsZC5kaXNwb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLyogLi4uICovXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFNjaGVkdWxlIGFzeW5jIGF0IHJ1bnRpbWUsIGZsdXNoIHN5bmMgaW4gdGVzdGluZ1xuICAgICAgICBpZiAodHlwZW9mIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHVuc3RhYmxlX0lkbGVQcmlvcml0eSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShwYXJlbnRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHN3aXRjaEluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmO1xuICAgIGNvbnN0IHBhcmVudCA9IChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRfX3IzZi5wYXJlbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHJldHVybjtcbiAgICBjb25zdCBuZXdJbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCBpbnN0YW5jZS5fX3IzZi5yb290KTtcblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzEzNDhcbiAgICAvLyBXaGVuIGFyZ3MgY2hhbmdlIHRoZSBpbnN0YW5jZSBoYXMgdG8gYmUgcmUtY29uc3RydWN0ZWQsIHdoaWNoIHRoZW5cbiAgICAvLyBmb3JjZXMgcjNmIHRvIHJlLXBhcmVudCB0aGUgY2hpbGRyZW4gYW5kIG5vbi1zY2VuZSBvYmplY3RzXG4gICAgaWYgKGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGluc3RhbmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIGlmIChjaGlsZC5fX3IzZikgYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlLmNoaWxkcmVuID0gaW5zdGFuY2UuY2hpbGRyZW4uZmlsdGVyKGNoaWxkID0+ICFjaGlsZC5fX3IzZik7XG4gICAgfVxuICAgIGluc3RhbmNlLl9fcjNmLm9iamVjdHMuZm9yRWFjaChjaGlsZCA9PiBhcHBlbmRDaGlsZChuZXdJbnN0YW5jZSwgY2hpbGQpKTtcbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzID0gW107XG4gICAgaWYgKCFpbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCkge1xuICAgICAgcmVtb3ZlQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChuZXdJbnN0YW5jZS5wYXJlbnQpIHtcbiAgICAgIG5ld0luc3RhbmNlLl9fcjNmLmF1dG9SZW1vdmVkQmVmb3JlQXBwZW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQocGFyZW50LCBuZXdJbnN0YW5jZSk7XG5cbiAgICAvLyBSZS1iaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKG5ld0luc3RhbmNlLnJheWNhc3QgJiYgbmV3SW5zdGFuY2UuX19yM2YuZXZlbnRDb3VudCkge1xuICAgICAgY29uc3Qgcm9vdFN0YXRlID0gbmV3SW5zdGFuY2UuX19yM2Yucm9vdC5nZXRTdGF0ZSgpO1xuICAgICAgcm9vdFN0YXRlLmludGVybmFsLmludGVyYWN0aW9uLnB1c2gobmV3SW5zdGFuY2UpO1xuICAgIH1cbiAgICBbZmliZXIsIGZpYmVyLmFsdGVybmF0ZV0uZm9yRWFjaChmaWJlciA9PiB7XG4gICAgICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIGlmIChmaWJlci5yZWYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpYmVyLnJlZiA9PT0gJ2Z1bmN0aW9uJykgZmliZXIucmVmKG5ld0luc3RhbmNlKTtlbHNlIGZpYmVyLnJlZi5jdXJyZW50ID0gbmV3SW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIERvbid0IGhhbmRsZSB0ZXh0IGluc3RhbmNlcywgd2FybiBvbiB1bmRlZmluZWQgYmVoYXZpb3JcbiAgY29uc3QgaGFuZGxlVGV4dEluc3RhbmNlID0gKCkgPT4gY29uc29sZS53YXJuKCdUZXh0IGlzIG5vdCBhbGxvd2VkIGluIHRoZSBSM0YgdHJlZSEgVGhpcyBjb3VsZCBiZSBzdHJheSB3aGl0ZXNwYWNlIG9yIGNoYXJhY3RlcnMuJyk7XG4gIGNvbnN0IHJlY29uY2lsZXIgPSBSZWNvbmNpbGVyKHtcbiAgICBjcmVhdGVJbnN0YW5jZSxcbiAgICByZW1vdmVDaGlsZCxcbiAgICBhcHBlbmRDaGlsZCxcbiAgICBhcHBlbmRJbml0aWFsQ2hpbGQ6IGFwcGVuZENoaWxkLFxuICAgIGluc2VydEJlZm9yZSxcbiAgICBzdXBwb3J0c011dGF0aW9uOiB0cnVlLFxuICAgIGlzUHJpbWFyeVJlbmRlcmVyOiBmYWxzZSxcbiAgICBzdXBwb3J0c1BlcnNpc3RlbmNlOiBmYWxzZSxcbiAgICBzdXBwb3J0c0h5ZHJhdGlvbjogZmFsc2UsXG4gICAgbm9UaW1lb3V0OiAtMSxcbiAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcblxuICAgICAgLy8gTGluayBjdXJyZW50IHJvb3QgdG8gdGhlIGRlZmF1bHQgc2NlbmVcbiAgICAgIHNjZW5lLl9fcjNmLnJvb3QgPSBjb250YWluZXI7XG4gICAgICBhcHBlbmRDaGlsZChzY2VuZSwgY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiAoY29udGFpbmVyLCBjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xuICAgICAgcmVtb3ZlQ2hpbGQoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlOiAoY29udGFpbmVyLCBjaGlsZCwgYmVmb3JlQ2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQgfHwgIWJlZm9yZUNoaWxkKSByZXR1cm47XG5cbiAgICAgIC8vIERvbid0IGFwcGVuZCB0byB1bm1vdW50ZWQgY29udGFpbmVyXG4gICAgICBjb25zdCBzY2VuZSA9IGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lO1xuICAgICAgaWYgKCFzY2VuZS5fX3IzZikgcmV0dXJuO1xuICAgICAgaW5zZXJ0QmVmb3JlKHNjZW5lLCBjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgZ2V0Um9vdEhvc3RDb250ZXh0OiAoKSA9PiBudWxsLFxuICAgIGdldENoaWxkSG9zdENvbnRleHQ6IHBhcmVudEhvc3RDb250ZXh0ID0+IHBhcmVudEhvc3RDb250ZXh0LFxuICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMiA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjIgOiB7fTtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFJldHVybmluZyB0cnVlIHdpbGwgdHJpZ2dlciBjb21taXRNb3VudFxuICAgICAgcmV0dXJuIEJvb2xlYW4obG9jYWxTdGF0ZS5oYW5kbGVycyk7XG4gICAgfSxcbiAgICBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCBfdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmMztcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcblxuICAgICAgLy8gQ3JlYXRlIGRpZmYtc2V0c1xuICAgICAgaWYgKGxvY2FsU3RhdGUucHJpbWl0aXZlICYmIG5ld1Byb3BzLm9iamVjdCAmJiBuZXdQcm9wcy5vYmplY3QgIT09IGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBbdHJ1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZGF0YSBvYmplY3QsIGxldCdzIGV4dHJhY3QgY3JpdGljYWwgaW5mb3JtYXRpb24gYWJvdXQgaXRcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFyZ3M6IGFyZ3NOZXcgPSBbXSxcbiAgICAgICAgICBjaGlsZHJlbjogY04sXG4gICAgICAgICAgLi4ucmVzdE5ld1xuICAgICAgICB9ID0gbmV3UHJvcHM7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzT2xkID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNPLFxuICAgICAgICAgIC4uLnJlc3RPbGRcbiAgICAgICAgfSA9IG9sZFByb3BzO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGFuIG9iamVjdCBvciBsaXRlcmFsIHdhcyBwYXNzZWQgZm9yIGFyZ3NcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3NOZXcpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogdGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAgIC8vIElmIGl0IGhhcyBuZXcgcHJvcHMgb3IgYXJndW1lbnRzLCB0aGVuIGl0IG5lZWRzIHRvIGJlIHJlLWluc3RhbnRpYXRlZFxuICAgICAgICBpZiAoYXJnc05ldy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICE9PSBhcmdzT2xkW2luZGV4XSkpIHJldHVybiBbdHJ1ZV07XG4gICAgICAgIC8vIENyZWF0ZSBhIGRpZmYtc2V0LCBmbGFnIGlmIHRoZXJlIGFyZSBhbnkgY2hhbmdlc1xuICAgICAgICBjb25zdCBkaWZmID0gZGlmZlByb3BzKGluc3RhbmNlLCByZXN0TmV3LCByZXN0T2xkLCB0cnVlKTtcbiAgICAgICAgaWYgKGRpZmYuY2hhbmdlcy5sZW5ndGgpIHJldHVybiBbZmFsc2UsIGRpZmZdO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBkbyBub3QgdG91Y2ggdGhlIGluc3RhbmNlXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCBbcmVjb25zdHJ1Y3QsIGRpZmZdLCB0eXBlLCBfb2xkUHJvcHMsIG5ld1Byb3BzLCBmaWJlcikge1xuICAgICAgLy8gUmVjb25zdHJ1Y3Qgd2hlbiBhcmdzIG9yIDxwcmltaXRpdmUgb2JqZWN0PXsuLi59IGhhdmUgY2hhbmdlc1xuICAgICAgaWYgKHJlY29uc3RydWN0KSBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKTtcbiAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG92ZXJ3cml0ZSBwcm9wc1xuICAgICAgZWxzZSBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRpZmYpO1xuICAgIH0sXG4gICAgY29tbWl0TW91bnQoaW5zdGFuY2UsIF90eXBlLCBfcHJvcHMsIF9pbnQpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y0O1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDI3MVxuICAgICAgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSBldmVudHMgYXJlIG9ubHkgYWRkZWQgb25jZSB0byB0aGUgY2VudHJhbCBjb250YWluZXJcbiAgICAgIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmNCA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNCA6IHt9O1xuICAgICAgaWYgKGluc3RhbmNlLnJheWNhc3QgJiYgbG9jYWxTdGF0ZS5oYW5kbGVycyAmJiBsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHtcbiAgICAgICAgaW5zdGFuY2UuX19yM2Yucm9vdC5nZXRTdGF0ZSgpLmludGVybmFsLmludGVyYWN0aW9uLnB1c2goaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0UHVibGljSW5zdGFuY2U6IGluc3RhbmNlID0+IGluc3RhbmNlLFxuICAgIHByZXBhcmVGb3JDb21taXQ6ICgpID0+IG51bGwsXG4gICAgcHJlcGFyZVBvcnRhbE1vdW50OiBjb250YWluZXIgPT4gcHJlcGFyZShjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZSksXG4gICAgcmVzZXRBZnRlckNvbW1pdDogKCkgPT4ge30sXG4gICAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6ICgpID0+IGZhbHNlLFxuICAgIGNsZWFyQ29udGFpbmVyOiAoKSA9PiBmYWxzZSxcbiAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y1O1xuICAgICAgLy8gRGV0YWNoIHdoaWxlIHRoZSBpbnN0YW5jZSBpcyBoaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNSA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNSA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBkZXRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCkgaW5zdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIHVuaGlkZUluc3RhbmNlKGluc3RhbmNlLCBwcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjY7XG4gICAgICAvLyBSZS1hdHRhY2ggd2hlbiB0aGUgaW5zdGFuY2UgaXMgdW5oaWRkZW5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYXR0YWNoOiB0eXBlLFxuICAgICAgICBwYXJlbnRcbiAgICAgIH0gPSAoX2luc3RhbmNlJF9fcjNmNiA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmNiA6IHt9O1xuICAgICAgaWYgKHR5cGUgJiYgcGFyZW50KSBhdHRhY2gocGFyZW50LCBpbnN0YW5jZSwgdHlwZSk7XG4gICAgICBpZiAoaW5zdGFuY2UuaXNPYmplY3QzRCAmJiBwcm9wcy52aXNpYmxlID09IG51bGwgfHwgcHJvcHMudmlzaWJsZSkgaW5zdGFuY2UudmlzaWJsZSA9IHRydWU7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH0sXG4gICAgY3JlYXRlVGV4dEluc3RhbmNlOiBoYW5kbGVUZXh0SW5zdGFuY2UsXG4gICAgaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIHVuaGlkZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkxNjM1Njg3NFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBnZXRDdXJyZW50RXZlbnRQcmlvcml0eTogKCkgPT4gX2dldEV2ZW50UHJpb3JpdHkgPyBfZ2V0RXZlbnRQcmlvcml0eSgpIDogRGVmYXVsdEV2ZW50UHJpb3JpdHksXG4gICAgYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyOiAoKSA9PiB7fSxcbiAgICBhZnRlckFjdGl2ZUluc3RhbmNlQmx1cjogKCkgPT4ge30sXG4gICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlOiAoKSA9PiB7fSxcbiAgICBub3c6IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXMuZnVuKHBlcmZvcm1hbmNlLm5vdykgPyBwZXJmb3JtYW5jZS5ub3cgOiBpcy5mdW4oRGF0ZS5ub3cpID8gRGF0ZS5ub3cgOiAoKSA9PiAwLFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMzYwI2Rpc2N1c3Npb25fcjkyMDg4MzUwM1xuICAgIHNjaGVkdWxlVGltZW91dDogaXMuZnVuKHNldFRpbWVvdXQpID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZCxcbiAgICBjYW5jZWxUaW1lb3V0OiBpcy5mdW4oY2xlYXJUaW1lb3V0KSA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZFxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICByZWNvbmNpbGVyLFxuICAgIGFwcGx5UHJvcHM6IGFwcGx5UHJvcHMkMVxuICB9O1xufVxuXG52YXIgX3dpbmRvdyRkb2N1bWVudCwgX3dpbmRvdyRuYXZpZ2F0b3I7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIHdpdGggY29ycmVjdCBUUyB0eXBlIGluZmVyZW5jZSBpZiBhbiBvYmplY3QgaGFzIGEgY29uZmlndXJhYmxlIGNvbG9yIHNwYWNlIChzaW5jZSByMTUyKS5cbiAqL1xuY29uc3QgaGFzQ29sb3JTcGFjZSA9IG9iamVjdCA9PiAnY29sb3JTcGFjZScgaW4gb2JqZWN0IHx8ICdvdXRwdXRDb2xvclNwYWNlJyBpbiBvYmplY3Q7XG4vKipcbiAqIFRoZSBjdXJyZW50IFRIUkVFLkNvbG9yTWFuYWdlbWVudCBpbnN0YW5jZSwgaWYgcHJlc2VudC5cbiAqL1xuY29uc3QgZ2V0Q29sb3JNYW5hZ2VtZW50ID0gKCkgPT4ge1xuICB2YXIgX0NvbG9yTWFuYWdlbWVudDtcbiAgcmV0dXJuIChfQ29sb3JNYW5hZ2VtZW50ID0gY2F0YWxvZ3VlLkNvbG9yTWFuYWdlbWVudCkgIT0gbnVsbCA/IF9Db2xvck1hbmFnZW1lbnQgOiBudWxsO1xufTtcbmNvbnN0IGlzT3J0aG9ncmFwaGljQ2FtZXJhID0gZGVmID0+IGRlZiAmJiBkZWYuaXNPcnRob2dyYXBoaWNDYW1lcmE7XG5jb25zdCBpc1JlZiA9IG9iaiA9PiBvYmogJiYgb2JqLmhhc093blByb3BlcnR5KCdjdXJyZW50Jyk7XG5cbi8qKlxuICogQW4gU1NSLWZyaWVuZGx5IHVzZUxheW91dEVmZmVjdC5cbiAqXG4gKiBSZWFjdCBjdXJyZW50bHkgdGhyb3dzIGEgd2FybmluZyB3aGVuIHVzaW5nIHVzZUxheW91dEVmZmVjdCBvbiB0aGUgc2VydmVyLlxuICogVG8gZ2V0IGFyb3VuZCBpdCwgd2UgY2FuIGNvbmRpdGlvbmFsbHkgdXNlRWZmZWN0IG9uIHRoZSBzZXJ2ZXIgKG5vLW9wKSBhbmRcbiAqIHVzZUxheW91dEVmZmVjdCBlbHNld2hlcmUuXG4gKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0OTI3XG4gKi9cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAoKF93aW5kb3ckZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQpICE9IG51bGwgJiYgX3dpbmRvdyRkb2N1bWVudC5jcmVhdGVFbGVtZW50IHx8ICgoX3dpbmRvdyRuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yKSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyRuYXZpZ2F0b3IucHJvZHVjdCkgPT09ICdSZWFjdE5hdGl2ZScpID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuZnVuY3Rpb24gdXNlTXV0YWJsZUNhbGxiYWNrKGZuKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihmbik7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAocmVmLmN1cnJlbnQgPSBmbiksIFtmbl0pO1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gQmxvY2soe1xuICBzZXRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0KG5ldyBQcm9taXNlKCgpID0+IG51bGwpKTtcbiAgICByZXR1cm4gKCkgPT4gc2V0KGZhbHNlKTtcbiAgfSwgW3NldF0pO1xuICByZXR1cm4gbnVsbDtcbn1cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGVycm9yOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyKSB7XG4gICAgdGhpcy5wcm9wcy5zZXQoZXJyKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuZXJyb3IgPyBudWxsIDogdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfVxufVxuRXJyb3JCb3VuZGFyeS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSAoKSA9PiAoe1xuICBlcnJvcjogdHJ1ZVxufSk7XG5jb25zdCBERUZBVUxUID0gJ19fZGVmYXVsdCc7XG5jb25zdCBERUZBVUxUUyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlzRGlmZlNldCA9IGRlZiA9PiBkZWYgJiYgISFkZWYubWVtb2l6ZWQgJiYgISFkZWYuY2hhbmdlcztcbmZ1bmN0aW9uIGNhbGN1bGF0ZURwcihkcHIpIHtcbiAgdmFyIF93aW5kb3ckZGV2aWNlUGl4ZWxSYTtcbiAgLy8gRXJyIG9uIHRoZSBzaWRlIG9mIHByb2dyZXNzIGJ5IGFzc3VtaW5nIDJ4IGRwciBpZiB3ZSBjYW4ndCBkZXRlY3QgaXRcbiAgLy8gVGhpcyB3aWxsIGhhcHBlbiBpbiB3b3JrZXJzIHdoZXJlIHdpbmRvdyBpcyBkZWZpbmVkIGJ1dCBkcHIgaXNuJ3QuXG4gIGNvbnN0IHRhcmdldCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gKF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSAhPSBudWxsID8gX3dpbmRvdyRkZXZpY2VQaXhlbFJhIDogMiA6IDE7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGRwcikgPyBNYXRoLm1pbihNYXRoLm1heChkcHJbMF0sIHRhcmdldCksIGRwclsxXSkgOiBkcHI7XG59XG5cbi8qKlxuICogUmV0dXJucyBpbnN0YW5jZSByb290IHN0YXRlXG4gKi9cbmNvbnN0IGdldFJvb3RTdGF0ZSA9IG9iaiA9PiB7XG4gIHZhciBfcjNmO1xuICByZXR1cm4gKF9yM2YgPSBvYmouX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfcjNmLnJvb3QuZ2V0U3RhdGUoKTtcbn07XG4vLyBBIGNvbGxlY3Rpb24gb2YgY29tcGFyZSBmdW5jdGlvbnNcbmNvbnN0IGlzID0ge1xuICBvYmo6IGEgPT4gYSA9PT0gT2JqZWN0KGEpICYmICFpcy5hcnIoYSkgJiYgdHlwZW9mIGEgIT09ICdmdW5jdGlvbicsXG4gIGZ1bjogYSA9PiB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyxcbiAgc3RyOiBhID0+IHR5cGVvZiBhID09PSAnc3RyaW5nJyxcbiAgbnVtOiBhID0+IHR5cGVvZiBhID09PSAnbnVtYmVyJyxcbiAgYm9vOiBhID0+IHR5cGVvZiBhID09PSAnYm9vbGVhbicsXG4gIHVuZDogYSA9PiBhID09PSB2b2lkIDAsXG4gIGFycjogYSA9PiBBcnJheS5pc0FycmF5KGEpLFxuICBlcXUoYSwgYiwge1xuICAgIGFycmF5cyA9ICdzaGFsbG93JyxcbiAgICBvYmplY3RzID0gJ3JlZmVyZW5jZScsXG4gICAgc3RyaWN0ID0gdHJ1ZVxuICB9ID0ge30pIHtcbiAgICAvLyBXcm9uZyB0eXBlIG9yIG9uZSBvZiB0aGUgdHdvIHVuZGVmaW5lZCwgZG9lc24ndCBtYXRjaFxuICAgIGlmICh0eXBlb2YgYSAhPT0gdHlwZW9mIGIgfHwgISFhICE9PSAhIWIpIHJldHVybiBmYWxzZTtcbiAgICAvLyBBdG9taWMsIGp1c3QgY29tcGFyZSBhIGFnYWluc3QgYlxuICAgIGlmIChpcy5zdHIoYSkgfHwgaXMubnVtKGEpKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc09iaiA9IGlzLm9iaihhKTtcbiAgICBpZiAoaXNPYmogJiYgb2JqZWN0cyA9PT0gJ3JlZmVyZW5jZScpIHJldHVybiBhID09PSBiO1xuICAgIGNvbnN0IGlzQXJyID0gaXMuYXJyKGEpO1xuICAgIGlmIChpc0FyciAmJiBhcnJheXMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBBcnJheSBvciBPYmplY3QsIHNoYWxsb3cgY29tcGFyZSBmaXJzdCB0byBzZWUgaWYgaXQncyBhIG1hdGNoXG4gICAgaWYgKChpc0FyciB8fCBpc09iaikgJiYgYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgLy8gTGFzdCByZXNvcnQsIGdvIHRocm91Z2gga2V5c1xuICAgIGxldCBpO1xuICAgIC8vIENoZWNrIGlmIGEgaGFzIGFsbCB0aGUga2V5cyBvZiBiXG4gICAgZm9yIChpIGluIGEpIGlmICghKGkgaW4gYikpIHJldHVybiBmYWxzZTtcbiAgICAvLyBDaGVjayBpZiB2YWx1ZXMgYmV0d2VlbiBrZXlzIG1hdGNoXG4gICAgaWYgKGlzT2JqICYmIGFycmF5cyA9PT0gJ3NoYWxsb3cnICYmIG9iamVjdHMgPT09ICdzaGFsbG93Jykge1xuICAgICAgZm9yIChpIGluIHN0cmljdCA/IGIgOiBhKSBpZiAoIWlzLmVxdShhW2ldLCBiW2ldLCB7XG4gICAgICAgIHN0cmljdCxcbiAgICAgICAgb2JqZWN0czogJ3JlZmVyZW5jZSdcbiAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgaSBpcyB1bmRlZmluZWRcbiAgICBpZiAoaXMudW5kKGkpKSB7XG4gICAgICAvLyBJZiBib3RoIGFycmF5cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzQXJyICYmIGEubGVuZ3RoID09PSAwICYmIGIubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIElmIGJvdGggb2JqZWN0cyBhcmUgZW1wdHkgd2UgY29uc2lkZXIgdGhlbSBlcXVhbFxuICAgICAgaWYgKGlzT2JqICYmIE9iamVjdC5rZXlzKGEpLmxlbmd0aCA9PT0gMCAmJiBPYmplY3Qua2V5cyhiKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgLy8gT3RoZXJ3aXNlIG1hdGNoIHRoZW0gYnkgdmFsdWVcbiAgICAgIGlmIChhICE9PSBiKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG4vKipcbiAqIENvbGxlY3RzIG5vZGVzIGFuZCBtYXRlcmlhbHMgZnJvbSBhIFRIUkVFLk9iamVjdDNELlxuICovXG5mdW5jdGlvbiBidWlsZEdyYXBoKG9iamVjdCkge1xuICBjb25zdCBkYXRhID0ge1xuICAgIG5vZGVzOiB7fSxcbiAgICBtYXRlcmlhbHM6IHt9XG4gIH07XG4gIGlmIChvYmplY3QpIHtcbiAgICBvYmplY3QudHJhdmVyc2Uob2JqID0+IHtcbiAgICAgIGlmIChvYmoubmFtZSkgZGF0YS5ub2Rlc1tvYmoubmFtZV0gPSBvYmo7XG4gICAgICBpZiAob2JqLm1hdGVyaWFsICYmICFkYXRhLm1hdGVyaWFsc1tvYmoubWF0ZXJpYWwubmFtZV0pIGRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSA9IG9iai5tYXRlcmlhbDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gRGlzcG9zZXMgYW4gb2JqZWN0IGFuZCBhbGwgaXRzIHByb3BlcnRpZXNcbmZ1bmN0aW9uIGRpc3Bvc2Uob2JqKSB7XG4gIGlmIChvYmouZGlzcG9zZSAmJiBvYmoudHlwZSAhPT0gJ1NjZW5lJykgb2JqLmRpc3Bvc2UoKTtcbiAgZm9yIChjb25zdCBwIGluIG9iaikge1xuICAgIHAuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogcC5kaXNwb3NlKCk7XG4gICAgZGVsZXRlIG9ialtwXTtcbiAgfVxufVxuXG4vLyBFYWNoIG9iamVjdCBpbiB0aGUgc2NlbmUgY2FycmllcyBhIHNtYWxsIExvY2FsU3RhdGUgZGVzY3JpcHRvclxuZnVuY3Rpb24gcHJlcGFyZShvYmplY3QsIHN0YXRlKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0O1xuICBpbnN0YW5jZS5fX3IzZiA9IHtcbiAgICB0eXBlOiAnJyxcbiAgICByb290OiBudWxsLFxuICAgIHByZXZpb3VzQXR0YWNoOiBudWxsLFxuICAgIG1lbW9pemVkUHJvcHM6IHt9LFxuICAgIGV2ZW50Q291bnQ6IDAsXG4gICAgaGFuZGxlcnM6IHt9LFxuICAgIG9iamVjdHM6IFtdLFxuICAgIHBhcmVudDogbnVsbCxcbiAgICAuLi5zdGF0ZVxuICB9O1xuICByZXR1cm4gb2JqZWN0O1xufVxuZnVuY3Rpb24gcmVzb2x2ZShpbnN0YW5jZSwga2V5KSB7XG4gIGxldCB0YXJnZXQgPSBpbnN0YW5jZTtcbiAgaWYgKGtleS5pbmNsdWRlcygnLScpKSB7XG4gICAgY29uc3QgZW50cmllcyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGxhc3QgPSBlbnRyaWVzLnBvcCgpO1xuICAgIHRhcmdldCA9IGVudHJpZXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgdGFyZ2V0LFxuICAgICAga2V5OiBsYXN0XG4gICAgfTtcbiAgfSBlbHNlIHJldHVybiB7XG4gICAgdGFyZ2V0LFxuICAgIGtleVxuICB9O1xufVxuXG4vLyBDaGVja3MgaWYgYSBkYXNoLWNhc2VkIHN0cmluZyBlbmRzIHdpdGggYW4gaW50ZWdlclxuY29uc3QgSU5ERVhfUkVHRVggPSAvLVxcZCskLztcbmZ1bmN0aW9uIGF0dGFjaChwYXJlbnQsIGNoaWxkLCB0eXBlKSB7XG4gIGlmIChpcy5zdHIodHlwZSkpIHtcbiAgICAvLyBJZiBhdHRhY2hpbmcgaW50byBhbiBhcnJheSAoZm9vLTApLCBjcmVhdGUgb25lXG4gICAgaWYgKElOREVYX1JFR0VYLnRlc3QodHlwZSkpIHtcbiAgICAgIGNvbnN0IHJvb3QgPSB0eXBlLnJlcGxhY2UoSU5ERVhfUkVHRVgsICcnKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXlcbiAgICAgIH0gPSByZXNvbHZlKHBhcmVudCwgcm9vdCk7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pKSB0YXJnZXRba2V5XSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHR5cGUpO1xuICAgIGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoID0gdGFyZ2V0W2tleV07XG4gICAgdGFyZ2V0W2tleV0gPSBjaGlsZDtcbiAgfSBlbHNlIGNoaWxkLl9fcjNmLnByZXZpb3VzQXR0YWNoID0gdHlwZShwYXJlbnQsIGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGRldGFjaChwYXJlbnQsIGNoaWxkLCB0eXBlKSB7XG4gIHZhciBfY2hpbGQkX19yM2YsIF9jaGlsZCRfX3IzZjI7XG4gIGlmIChpcy5zdHIodHlwZSkpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXlcbiAgICB9ID0gcmVzb2x2ZShwYXJlbnQsIHR5cGUpO1xuICAgIGNvbnN0IHByZXZpb3VzID0gY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2g7XG4gICAgLy8gV2hlbiB0aGUgcHJldmlvdXMgdmFsdWUgd2FzIHVuZGVmaW5lZCwgaXQgbWVhbnMgdGhlIHZhbHVlIHdhcyBuZXZlciBzZXQgdG8gYmVnaW4gd2l0aFxuICAgIGlmIChwcmV2aW91cyA9PT0gdW5kZWZpbmVkKSBkZWxldGUgdGFyZ2V0W2tleV07XG4gICAgLy8gT3RoZXJ3aXNlIHNldCB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICBlbHNlIHRhcmdldFtrZXldID0gcHJldmlvdXM7XG4gIH0gZWxzZSAoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2YucHJldmlvdXNBdHRhY2ggPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZi5wcmV2aW91c0F0dGFjaChwYXJlbnQsIGNoaWxkKTtcbiAgKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHRydWUgOiBkZWxldGUgX2NoaWxkJF9fcjNmMi5wcmV2aW91c0F0dGFjaDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBwcmVwYXJlcyBhIHNldCBvZiBjaGFuZ2VzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBkaWZmUHJvcHMoaW5zdGFuY2UsIHtcbiAgY2hpbGRyZW46IGNOLFxuICBrZXk6IGtOLFxuICByZWY6IHJOLFxuICAuLi5wcm9wc1xufSwge1xuICBjaGlsZHJlbjogY1AsXG4gIGtleToga1AsXG4gIHJlZjogclAsXG4gIC4uLnByZXZpb3VzXG59ID0ge30sIHJlbW92ZSA9IGZhbHNlKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2Y7XG4gIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmIDoge307XG4gIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwcm9wcyk7XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcblxuICAvLyBDYXRjaCByZW1vdmVkIHByb3BzLCBwcmVwZW5kIHRoZW0gc28gdGhleSBjYW4gYmUgcmVzZXQgb3IgcmVtb3ZlZFxuICBpZiAocmVtb3ZlKSB7XG4gICAgY29uc3QgcHJldmlvdXNLZXlzID0gT2JqZWN0LmtleXMocHJldmlvdXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldmlvdXNLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByZXZpb3VzS2V5c1tpXSkpIGVudHJpZXMudW5zaGlmdChbcHJldmlvdXNLZXlzW2ldLCBERUZBVUxUICsgJ3JlbW92ZSddKTtcbiAgICB9XG4gIH1cbiAgZW50cmllcy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICB2YXIgX2luc3RhbmNlJF9fcjNmMjtcbiAgICAvLyBCYWlsIG91dCBvbiBwcmltaXRpdmUgb2JqZWN0XG4gICAgaWYgKChfaW5zdGFuY2UkX19yM2YyID0gaW5zdGFuY2UuX19yM2YpICE9IG51bGwgJiYgX2luc3RhbmNlJF9fcjNmMi5wcmltaXRpdmUgJiYga2V5ID09PSAnb2JqZWN0JykgcmV0dXJuO1xuICAgIC8vIFdoZW4gcHJvcHMgbWF0Y2ggYmFpbCBvdXRcbiAgICBpZiAoaXMuZXF1KHZhbHVlLCBwcmV2aW91c1trZXldKSkgcmV0dXJuO1xuICAgIC8vIENvbGxlY3QgaGFuZGxlcnMgYW5kIGJhaWwgb3V0XG4gICAgaWYgKC9eb24oUG9pbnRlcnxDbGlja3xEb3VibGVDbGlja3xDb250ZXh0TWVudXxXaGVlbCkvLnRlc3Qoa2V5KSkgcmV0dXJuIGNoYW5nZXMucHVzaChba2V5LCB2YWx1ZSwgdHJ1ZSwgW11dKTtcbiAgICAvLyBTcGxpdCBkYXNoZWQgcHJvcHNcbiAgICBsZXQgZW50cmllcyA9IFtdO1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy0nKSkgZW50cmllcyA9IGtleS5zcGxpdCgnLScpO1xuICAgIGNoYW5nZXMucHVzaChba2V5LCB2YWx1ZSwgZmFsc2UsIGVudHJpZXNdKTtcblxuICAgIC8vIFJlc2V0IHBpZXJjZWQgcHJvcHNcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gcHJvcHNbcHJvcF07XG4gICAgICBpZiAocHJvcC5zdGFydHNXaXRoKGAke2tleX0tYCkpIGNoYW5nZXMucHVzaChbcHJvcCwgdmFsdWUsIGZhbHNlLCBwcm9wLnNwbGl0KCctJyldKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBtZW1vaXplZCA9IHtcbiAgICAuLi5wcm9wc1xuICB9O1xuICBpZiAobG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzICYmIGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcy5hcmdzKSBtZW1vaXplZC5hcmdzID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmFyZ3M7XG4gIGlmIChsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaCkgbWVtb2l6ZWQuYXR0YWNoID0gbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmF0dGFjaDtcbiAgcmV0dXJuIHtcbiAgICBtZW1vaXplZCxcbiAgICBjaGFuZ2VzXG4gIH07XG59XG5jb25zdCBfX0RFVl9fID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5cbi8vIFRoaXMgZnVuY3Rpb24gYXBwbGllcyBhIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBpbnN0YW5jZVxuZnVuY3Rpb24gYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkYXRhKSB7XG4gIHZhciBfaW5zdGFuY2UkX19yM2YzLCBfcm9vdCRnZXRTdGF0ZSwgX2luc3RhbmNlJF9fcjNmNDtcbiAgLy8gRmlsdGVyIGVxdWFscywgZXZlbnRzIGFuZCByZXNlcnZlZCBwcm9wc1xuICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjMgOiB7fTtcbiAgY29uc3Qgcm9vdCA9IGxvY2FsU3RhdGUucm9vdDtcbiAgY29uc3Qgcm9vdFN0YXRlID0gKF9yb290JGdldFN0YXRlID0gcm9vdCA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogcm9vdC5nZXRTdGF0ZSgpKSAhPSBudWxsID8gX3Jvb3QkZ2V0U3RhdGUgOiB7fTtcbiAgY29uc3Qge1xuICAgIG1lbW9pemVkLFxuICAgIGNoYW5nZXNcbiAgfSA9IGlzRGlmZlNldChkYXRhKSA/IGRhdGEgOiBkaWZmUHJvcHMoaW5zdGFuY2UsIGRhdGEpO1xuICBjb25zdCBwcmV2SGFuZGxlcnMgPSBsb2NhbFN0YXRlLmV2ZW50Q291bnQ7XG5cbiAgLy8gUHJlcGFyZSBtZW1vaXplZCBwcm9wc1xuICBpZiAoaW5zdGFuY2UuX19yM2YpIGluc3RhbmNlLl9fcjNmLm1lbW9pemVkUHJvcHMgPSBtZW1vaXplZDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtrZXksIHZhbHVlLCBpc0V2ZW50LCBrZXlzXSA9IGNoYW5nZXNbaV07XG5cbiAgICAvLyBBbGlhcyAob3V0cHV0KWVuY29kaW5nID0+IChvdXRwdXQpY29sb3JTcGFjZSAoc2luY2UgcjE1MilcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjgyOVxuICAgIGlmIChoYXNDb2xvclNwYWNlKGluc3RhbmNlKSkge1xuICAgICAgY29uc3Qgc1JHQkVuY29kaW5nID0gMzAwMTtcbiAgICAgIGNvbnN0IFNSR0JDb2xvclNwYWNlID0gJ3NyZ2InO1xuICAgICAgY29uc3QgTGluZWFyU1JHQkNvbG9yU3BhY2UgPSAnc3JnYi1saW5lYXInO1xuICAgICAgaWYgKGtleSA9PT0gJ2VuY29kaW5nJykge1xuICAgICAgICBrZXkgPSAnY29sb3JTcGFjZSc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ291dHB1dEVuY29kaW5nJykge1xuICAgICAgICBrZXkgPSAnb3V0cHV0Q29sb3JTcGFjZSc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT09IHNSR0JFbmNvZGluZyA/IFNSR0JDb2xvclNwYWNlIDogTGluZWFyU1JHQkNvbG9yU3BhY2U7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjdXJyZW50SW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBsZXQgdGFyZ2V0UHJvcCA9IGN1cnJlbnRJbnN0YW5jZVtrZXldO1xuXG4gICAgLy8gUmV2b2x2ZSBkYXNoZWQgcHJvcHNcbiAgICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICAgIHRhcmdldFByb3AgPSBrZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjY1trZXldLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGF0b21pYywgaXQgZm9yY2VzIHVzIHRvIHN3aXRjaCB0aGUgcm9vdFxuICAgICAgaWYgKCEodGFyZ2V0UHJvcCAmJiB0YXJnZXRQcm9wLnNldCkpIHtcbiAgICAgICAgY29uc3QgW25hbWUsIC4uLnJldmVyc2VFbnRyaWVzXSA9IGtleXMucmV2ZXJzZSgpO1xuICAgICAgICBjdXJyZW50SW5zdGFuY2UgPSByZXZlcnNlRW50cmllcy5yZXZlcnNlKCkucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICAgICAga2V5ID0gbmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8yMTIwOVxuICAgIC8vIEhNUi9mYXN0LXJlZnJlc2ggcmVsaWVzIG9uIHRoZSBhYmlsaXR5IHRvIGNhbmNlbCBvdXQgcHJvcHMsIGJ1dCB0aHJlZWpzXG4gICAgLy8gaGFzIG5vIG1lYW5zIHRvIGRvIHRoaXMuIEhlbmNlIHdlIGN1cmF0ZSBhIHNtYWxsIGNvbGxlY3Rpb24gb2YgdmFsdWUtY2xhc3Nlc1xuICAgIC8vIHdpdGggdGhlaXIgcmVzcGVjdGl2ZSBjb25zdHJ1Y3Rvci9zZXQgYXJndW1lbnRzXG4gICAgLy8gRm9yIHJlbW92ZWQgcHJvcHMsIHRyeSB0byBzZXQgZGVmYXVsdCB2YWx1ZXMsIGlmIHBvc3NpYmxlXG4gICAgaWYgKHZhbHVlID09PSBERUZBVUxUICsgJ3JlbW92ZScpIHtcbiAgICAgIGlmIChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IpIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgYmxhbmsgc2xhdGUgb2YgdGhlIGluc3RhbmNlIGFuZCBjb3B5IHRoZSBwYXJ0aWN1bGFyIHBhcmFtZXRlci5cbiAgICAgICAgbGV0IGN0b3IgPSBERUZBVUxUUy5nZXQoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgaWYgKCFjdG9yKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGN0b3IgPSBuZXcgY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yKCk7XG4gICAgICAgICAgREVGQVVMVFMuc2V0KGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3RvciwgY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBjdG9yW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnN0YW5jZSBkb2VzIG5vdCBoYXZlIGNvbnN0cnVjdG9yLCBqdXN0IHNldCBpdCB0byAwXG4gICAgICAgIHZhbHVlID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggcG9pbnRlciBldmVudHMgLi4uXG4gICAgaWYgKGlzRXZlbnQpIHtcbiAgICAgIGlmICh2YWx1ZSkgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldID0gdmFsdWU7ZWxzZSBkZWxldGUgbG9jYWxTdGF0ZS5oYW5kbGVyc1trZXldO1xuICAgICAgbG9jYWxTdGF0ZS5ldmVudENvdW50ID0gT2JqZWN0LmtleXMobG9jYWxTdGF0ZS5oYW5kbGVycykubGVuZ3RoO1xuICAgIH1cbiAgICAvLyBTcGVjaWFsIHRyZWF0bWVudCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yIHNldC9jb3B5LCBhbmQgbGF5ZXJzXG4gICAgZWxzZSBpZiAodGFyZ2V0UHJvcCAmJiB0YXJnZXRQcm9wLnNldCAmJiAodGFyZ2V0UHJvcC5jb3B5IHx8IHRhcmdldFByb3AgaW5zdGFuY2VvZiBUSFJFRS5MYXllcnMpKSB7XG4gICAgICAvLyBJZiB2YWx1ZSBpcyBhbiBhcnJheVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICh0YXJnZXRQcm9wLmZyb21BcnJheSkgdGFyZ2V0UHJvcC5mcm9tQXJyYXkodmFsdWUpO2Vsc2UgdGFyZ2V0UHJvcC5zZXQoLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gVGVzdCBhZ2FpbiB0YXJnZXQuY29weShjbGFzcykgbmV4dCAuLi5cbiAgICAgIGVsc2UgaWYgKHRhcmdldFByb3AuY29weSAmJiB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiAoXG4gICAgICAvLyBTb21lIGVudmlyb25tZW50cyBtYXkgYnJlYWsgc3RyaWN0IGlkZW50aXR5IGNoZWNrcyBieSBkdXBsaWNhdGluZyB2ZXJzaW9ucyBvZiB0aHJlZS5qcy5cbiAgICAgIC8vIExvb3NlbiB0byB1bm1pbmlmaWVkIG5hbWVzLCBpZ25vcmluZyBkZXNjZW5kZW50cy5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzI4NTZcbiAgICAgIC8vIFRPRE86IGZpeCB1cHN0cmVhbSBhbmQgcmVtb3ZlIGluIHY5XG4gICAgICBfX0RFVl9fID8gdGFyZ2V0UHJvcC5jb25zdHJ1Y3Rvci5uYW1lID09PSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIDogdGFyZ2V0UHJvcC5jb25zdHJ1Y3RvciA9PT0gdmFsdWUuY29uc3RydWN0b3IpKSB7XG4gICAgICAgIHRhcmdldFByb3AuY29weSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBub3RoaW5nIGVsc2UgZml0cywganVzdCBzZXQgdGhlIHNpbmdsZSB2YWx1ZSwgaWdub3JlIHVuZGVmaW5lZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjc0XG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGlzQ29sb3IgPSB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuQ29sb3I7XG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgYXJyYXkgc2NhbGFyc1xuICAgICAgICBpZiAoIWlzQ29sb3IgJiYgdGFyZ2V0UHJvcC5zZXRTY2FsYXIpIHRhcmdldFByb3Auc2V0U2NhbGFyKHZhbHVlKTtcbiAgICAgICAgLy8gTGF5ZXJzIGhhdmUgbm8gY29weSBmdW5jdGlvbiwgd2UgbXVzdCB0aGVyZWZvcmUgY29weSB0aGUgbWFzayBwcm9wZXJ0eVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzICYmIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSB0YXJnZXRQcm9wLm1hc2sgPSB2YWx1ZS5tYXNrO1xuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBzZXQgLi4uXG4gICAgICAgIGVsc2UgdGFyZ2V0UHJvcC5zZXQodmFsdWUpO1xuICAgICAgICAvLyBGb3IgdmVyc2lvbnMgb2YgdGhyZWUgd2hpY2ggZG9uJ3Qgc3VwcG9ydCBUSFJFRS5Db2xvck1hbmFnZW1lbnQsXG4gICAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIGNvbG9yc1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgICAgaWYgKCFnZXRDb2xvck1hbmFnZW1lbnQoKSAmJiAhcm9vdFN0YXRlLmxpbmVhciAmJiBpc0NvbG9yKSB0YXJnZXRQcm9wLmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIEVsc2UsIGp1c3Qgb3ZlcndyaXRlIHRoZSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50SW5zdGFuY2Vba2V5XSA9IHZhbHVlO1xuXG4gICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiB0ZXh0dXJlcywgZm9yIG5vdyAuLi5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgaWYgKGN1cnJlbnRJbnN0YW5jZVtrZXldIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSAmJlxuICAgICAgLy8gc1JHQiB0ZXh0dXJlcyBtdXN0IGJlIFJHQkE4IHNpbmNlIHIxMzcgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzMTI5XG4gICAgICBjdXJyZW50SW5zdGFuY2Vba2V5XS5mb3JtYXQgPT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgY3VycmVudEluc3RhbmNlW2tleV0udHlwZSA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gY3VycmVudEluc3RhbmNlW2tleV07XG4gICAgICAgIGlmIChoYXNDb2xvclNwYWNlKHRleHR1cmUpICYmIGhhc0NvbG9yU3BhY2Uocm9vdFN0YXRlLmdsKSkgdGV4dHVyZS5jb2xvclNwYWNlID0gcm9vdFN0YXRlLmdsLm91dHB1dENvbG9yU3BhY2U7ZWxzZSB0ZXh0dXJlLmVuY29kaW5nID0gcm9vdFN0YXRlLmdsLm91dHB1dEVuY29kaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICB9XG4gIGlmIChsb2NhbFN0YXRlLnBhcmVudCAmJiByb290U3RhdGUuaW50ZXJuYWwgJiYgaW5zdGFuY2UucmF5Y2FzdCAmJiBwcmV2SGFuZGxlcnMgIT09IGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgIC8vIFByZS1lbXB0aXZlbHkgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyXG4gICAgY29uc3QgaW5kZXggPSByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24uaW5kZXhPZihpbnN0YW5jZSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIHVwZGF0ZSBsaWZlY3ljbGUgd2hlbiBpdCBpcyBiZWluZyB1cGRhdGVkLCBidXQgb25seSB3aGVuIGl0IGlzIHBhcnQgb2YgdGhlIHNjZW5lLlxuICAvLyBTa2lwIHVwZGF0ZXMgdG8gdGhlIGBvblVwZGF0ZWAgcHJvcCBpdHNlbGZcbiAgY29uc3QgaXNDaXJjdWxhciA9IGNoYW5nZXMubGVuZ3RoID09PSAxICYmIGNoYW5nZXNbMF1bMF0gPT09ICdvblVwZGF0ZSc7XG4gIGlmICghaXNDaXJjdWxhciAmJiBjaGFuZ2VzLmxlbmd0aCAmJiAoX2luc3RhbmNlJF9fcjNmNCA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZjQucGFyZW50KSB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmNSwgX2luc3RhbmNlJF9fcjNmNSRyb290O1xuICBjb25zdCBzdGF0ZSA9IChfaW5zdGFuY2UkX19yM2Y1ID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiAoX2luc3RhbmNlJF9fcjNmNSRyb290ID0gX2luc3RhbmNlJF9fcjNmNS5yb290KSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmNSRyb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2Y1JHJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmludGVybmFsLmZyYW1lcyA9PT0gMCkgc3RhdGUuaW52YWxpZGF0ZSgpO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2Uub25VcGRhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLm9uVXBkYXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvOTJcbiAgLy8gRG8gbm90IG1lc3Mgd2l0aCB0aGUgY2FtZXJhIGlmIGl0IGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgaWYgKCFjYW1lcmEubWFudWFsKSB7XG4gICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgIGNhbWVyYS5sZWZ0ID0gc2l6ZS53aWR0aCAvIC0yO1xuICAgICAgY2FtZXJhLnJpZ2h0ID0gc2l6ZS53aWR0aCAvIDI7XG4gICAgICBjYW1lcmEudG9wID0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgY2FtZXJhLmJvdHRvbSA9IHNpemUuaGVpZ2h0IC8gLTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWVyYS5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMTc4XG4gICAgLy8gVXBkYXRlIG1hdHJpeCB3b3JsZCBzaW5jZSB0aGUgcmVuZGVyZXIgaXMgYSBmcmFtZSBsYXRlXG4gICAgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUlkKGV2ZW50KSB7XG4gIHJldHVybiAoZXZlbnQuZXZlbnRPYmplY3QgfHwgZXZlbnQub2JqZWN0KS51dWlkICsgJy8nICsgZXZlbnQuaW5kZXggKyBldmVudC5pbnN0YW5jZUlkO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIjZ2V0Y3VycmVudGV2ZW50cHJpb3JpdHlcbi8vIEdpdmVzIFJlYWN0IGEgY2x1ZSBhcyB0byBob3cgaW1wb3J0IHRoZSBjdXJyZW50IGludGVyYWN0aW9uIGlzXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KCkge1xuICB2YXIgX2dsb2JhbFNjb3BlJGV2ZW50O1xuICAvLyBHZXQgYSBoYW5kbGUgdG8gdGhlIGN1cnJlbnQgZ2xvYmFsIHNjb3BlIGluIHdpbmRvdyBhbmQgd29ya2VyIGNvbnRleHRzIGlmIGFibGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI0OTNcbiAgY29uc3QgZ2xvYmFsU2NvcGUgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c7XG4gIGlmICghZ2xvYmFsU2NvcGUpIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgY29uc3QgbmFtZSA9IChfZ2xvYmFsU2NvcGUkZXZlbnQgPSBnbG9iYWxTY29wZS5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxTY29wZSRldmVudC50eXBlO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdjbGljayc6XG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyZW50ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgY2FzZSAnd2hlZWwnOlxuICAgICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWxlYXNlIHBvaW50ZXIgY2FwdHVyZXMuXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGNhcHR1cmVkTWFwLCBvYmosIGNhcHR1cmVzLCBwb2ludGVySWQpIHtcbiAgY29uc3QgY2FwdHVyZURhdGEgPSBjYXB0dXJlcy5nZXQob2JqKTtcbiAgaWYgKGNhcHR1cmVEYXRhKSB7XG4gICAgY2FwdHVyZXMuZGVsZXRlKG9iaik7XG4gICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgY2FwdHVyaW5nIG9iamVjdCBmb3IgdGhpcyBwb2ludGVyXG4gICAgaWYgKGNhcHR1cmVzLnNpemUgPT09IDApIHtcbiAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShwb2ludGVySWQpO1xuICAgICAgY2FwdHVyZURhdGEudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpdml0eShzdG9yZSwgb2JqZWN0KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbFxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgLy8gUmVtb3ZlcyBldmVyeSB0cmFjZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YSBzdG9yZVxuICBpbnRlcm5hbC5pbnRlcmFjdGlvbiA9IGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmluaXRpYWxIaXRzID0gaW50ZXJuYWwuaW5pdGlhbEhpdHMuZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaG92ZXJlZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmV2ZW50T2JqZWN0ID09PSBvYmplY3QgfHwgdmFsdWUub2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZm9yRWFjaCgoY2FwdHVyZXMsIHBvaW50ZXJJZCkgPT4ge1xuICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBvYmplY3QsIGNhcHR1cmVzLCBwb2ludGVySWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cyhzdG9yZSkge1xuICAvKiogQ2FsY3VsYXRlcyBkZWx0YSAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHggPSBldmVudC5vZmZzZXRYIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzBdO1xuICAgIGNvbnN0IGR5ID0gZXZlbnQub2Zmc2V0WSAtIGludGVybmFsLmluaXRpYWxDbGlja1sxXTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gaW5zdGFuY2UgaGFzIGEgdmFsaWQgcG9pbnRlci1ldmVudCByZWdpc3RlcmVkLCB0aGlzIGV4Y2x1ZGVzIHNjcm9sbCwgY2xpY2tzIGV0YyAqL1xuICBmdW5jdGlvbiBmaWx0ZXJQb2ludGVyRXZlbnRzKG9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0cy5maWx0ZXIob2JqID0+IFsnTW92ZScsICdPdmVyJywgJ0VudGVyJywgJ091dCcsICdMZWF2ZSddLnNvbWUobmFtZSA9PiB7XG4gICAgICB2YXIgX3IzZjtcbiAgICAgIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2YuaGFuZGxlcnNbJ29uUG9pbnRlcicgKyBuYW1lXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuICAgIGNvbnN0IGV2ZW50c09iamVjdHMgPSBmaWx0ZXIgPyBmaWx0ZXIoc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24pIDogc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb247XG4gICAgLy8gUmVzZXQgYWxsIHJheWNhc3RlciBjYW1lcmFzIHRvIHVuZGVmaW5lZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoZXZlbnRzT2JqZWN0c1tpXSk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5wcmV2aW91c1Jvb3QpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSByb290LWxldmVsIHBvaW50ZXIgYW5kIHJheSBhcmUgc2V0IHVwXG4gICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmF5Y2FzdChvYmopIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAvLyBTa2lwIGV2ZW50IGhhbmRsaW5nIHdoZW4gbm9FdmVudHMgaXMgc2V0LCBvciB3aGVuIHRoZSByYXljYXN0ZXJzIGNhbWVyYSBpcyBudWxsXG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5ldmVudHMuZW5hYmxlZCB8fCBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgICAgIC8vIFdoZW4gdGhlIGNhbWVyYSBpcyB1bmRlZmluZWQgd2UgaGF2ZSB0byBjYWxsIHRoZSBldmVudCBsYXllcnMgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfc3RhdGUkcHJldmlvdXNSb290O1xuICAgICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlLCAoX3N0YXRlJHByZXZpb3VzUm9vdCA9IHN0YXRlLnByZXZpb3VzUm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIElmIHRoZSBjYW1lcmEgaXMgc3RpbGwgdW5kZWZpbmVkIHdlIGhhdmUgdG8gc2tpcCB0aGlzIGxheWVyIGVudGlyZWx5XG4gICAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0IGJ5IG9iamVjdFxuICAgICAgcmV0dXJuIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPyBzdGF0ZS5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG9iaiwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvLyBDb2xsZWN0IGV2ZW50c1xuICAgIGxldCBoaXRzID0gZXZlbnRzT2JqZWN0c1xuICAgIC8vIEludGVyc2VjdCBvYmplY3RzXG4gICAgLmZsYXRNYXAoaGFuZGxlUmF5Y2FzdClcbiAgICAvLyBTb3J0IGJ5IGV2ZW50IHByaW9yaXR5IGFuZCBkaXN0YW5jZVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhU3RhdGUgPSBnZXRSb290U3RhdGUoYS5vYmplY3QpO1xuICAgICAgY29uc3QgYlN0YXRlID0gZ2V0Um9vdFN0YXRlKGIub2JqZWN0KTtcbiAgICAgIGlmICghYVN0YXRlIHx8ICFiU3RhdGUpIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICAgIHJldHVybiBiU3RhdGUuZXZlbnRzLnByaW9yaXR5IC0gYVN0YXRlLmV2ZW50cy5wcmlvcml0eSB8fCBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICB9KVxuICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICBjb25zdCBpZCA9IG1ha2VJZChpdGVtKTtcbiAgICAgIGlmIChkdXBsaWNhdGVzLmhhcyhpZCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGR1cGxpY2F0ZXMuYWRkKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzFcbiAgICAvLyBBbGxvdyBjdXN0b20gdXNlcmxhbmQgaW50ZXJzZWN0IHNvcnQgb3JkZXIsIHRoaXMgbGlrZWx5IG9ubHkgbWFrZXMgc2Vuc2Ugb24gdGhlIHJvb3QgZmlsdGVyXG4gICAgaWYgKHN0YXRlLmV2ZW50cy5maWx0ZXIpIGhpdHMgPSBzdGF0ZS5ldmVudHMuZmlsdGVyKGhpdHMsIHN0YXRlKTtcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZXZlbnRzLCBmaW5kIHRoZSBldmVudCBzb3VyY2UgKGV2ZW50T2JqZWN0KVxuICAgIGZvciAoY29uc3QgaGl0IG9mIGhpdHMpIHtcbiAgICAgIGxldCBldmVudE9iamVjdCA9IGhpdC5vYmplY3Q7XG4gICAgICAvLyBCdWJibGUgZXZlbnQgdXBcbiAgICAgIHdoaWxlIChldmVudE9iamVjdCkge1xuICAgICAgICB2YXIgX3IzZjI7XG4gICAgICAgIGlmICgoX3IzZjIgPSBldmVudE9iamVjdC5fX3IzZikgIT0gbnVsbCAmJiBfcjNmMi5ldmVudENvdW50KSBpbnRlcnNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICBldmVudE9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRPYmplY3QgPSBldmVudE9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGludGVyYWN0aW9uIGlzIGNhcHR1cmVkLCBtYWtlIGFsbCBjYXB0dXJpbmcgdGFyZ2V0cyBwYXJ0IG9mIHRoZSBpbnRlcnNlY3QuXG4gICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBmb3IgKGxldCBjYXB0dXJlRGF0YSBvZiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIWR1cGxpY2F0ZXMuaGFzKG1ha2VJZChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pKSkgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgLyoqICBIYW5kbGVzIGludGVyc2VjdGlvbnMgYnkgZm9yd2FyZGluZyB0aGVtIHRvIGhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdHMoaW50ZXJzZWN0aW9ucywgZXZlbnQsIGRlbHRhLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiBhbnl0aGluZyBoYXMgYmVlbiBmb3VuZCwgZm9yd2FyZCBpdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoaGl0Lm9iamVjdCkgfHwgcm9vdFN0YXRlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgIGludGVybmFsXG4gICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgdW5wcm9qZWN0ZWRQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvaW50ZXIueCwgcG9pbnRlci55LCAwKS51bnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgdmFyIF9pbnRlcm5hbCRjYXB0dXJlZE1hcCwgX2ludGVybmFsJGNhcHR1cmVkTWFwMjtcbiAgICAgICAgICByZXR1cm4gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA9IChfaW50ZXJuYWwkY2FwdHVyZWRNYXAyID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIuaGFzKGhpdC5ldmVudE9iamVjdCkpICE9IG51bGwgPyBfaW50ZXJuYWwkY2FwdHVyZWRNYXAgOiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0UG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZURhdGEgPSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb246IGhpdCxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgYWRkIHRoZSBoaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBldmVudCBjYXB0dXJlZE1hcC5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkuc2V0KGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBub3QgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgY3JlYXRlIGEgbWFwXG4gICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBoaXRPYmplY3QsIGFuZCB0aGUgaGl0LiBoaXRPYmplY3QgaXMgdXNlZCBmb3JcbiAgICAgICAgICAgIC8vIGZhc3RlciBhY2Nlc3MuXG4gICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5zZXQoaWQsIG5ldyBNYXAoW1toaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhXV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVsZWFzZVBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgICAgICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVzLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCBuYXRpdmUgZXZlbnQgcHJvcHNcbiAgICAgICAgbGV0IGV4dHJhY3RFdmVudFByb3BzID0ge307XG4gICAgICAgIC8vIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgZXZlbnQncyBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgaW5oZXJpdGVkIG9uZXMuIE5hdGl2ZSBQb2ludGVyRXZlbnRzIGhhdmUgbW9zdCBvZiB0aGVpciBwcm9wcyBhcyBnZXR0ZXJzIHdoaWNoIGFyZSBpbmhlcml0ZWQsIGJ1dCBwb2x5ZmlsbGVkIFBvaW50ZXJFdmVudHMgaGF2ZSB0aGVtIGFsbCBhcyB0aGVpciBvd24gcHJvcGVydGllcyAoaS5lLiBub3QgaW5oZXJpdGVkKS4gV2UgY2FuJ3QgdXNlIE9iamVjdC5rZXlzKCkgb3IgT2JqZWN0LmVudHJpZXMoKSBhcyB0aGV5IG9ubHkgcmV0dXJuIFwib3duXCIgcHJvcGVydGllczsgbm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkgYXMgdGhhdCAqZG9lc24ndCogcmV0dXJuIFwib3duXCIgcHJvcGVydGllcywgb25seSBpbmhlcml0ZWQgb25lcy5cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGV2ZW50W3Byb3BdO1xuICAgICAgICAgIC8vIE9ubHkgY29weSBvdmVyIGF0b21pY3MsIGxlYXZlIGZ1bmN0aW9ucyBhbG9uZSBhcyB0aGVzZSBzaG91bGQgYmVcbiAgICAgICAgICAvLyBjYWxsZWQgYXMgZXZlbnQubmF0aXZlRXZlbnQuZm4oKVxuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdmdW5jdGlvbicpIGV4dHJhY3RFdmVudFByb3BzW3Byb3BdID0gcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJheWNhc3RFdmVudCA9IHtcbiAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgLi4uZXh0cmFjdEV2ZW50UHJvcHMsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgIHN0b3BwZWQ6IGxvY2FsU3RhdGUuc3RvcHBlZCxcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICB1bnByb2plY3RlZFBvaW50LFxuICAgICAgICAgIHJheTogcmF5Y2FzdGVyLnJheSxcbiAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAvLyBIaWphY2sgc3RvcFByb3BhZ2F0aW9uLCB3aGljaCBqdXN0IHNldHMgYSBmbGFnXG4gICAgICAgICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvNTk2XG4gICAgICAgICAgICAvLyBFdmVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIHN0b3AgcHJvcGFnYXRpb24gaWYgdGhlIHBvaW50ZXIgaGFzIGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzRm9yUG9pbnRlciA9ICdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpO1xuXG4gICAgICAgICAgICAvLyBXZSBvbmx5IGF1dGhvcml6ZSBzdG9wUHJvcGFnYXRpb24uLi5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIC4uLmlmIHRoaXMgcG9pbnRlciBoYXNuJ3QgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgIWNhcHR1cmVzRm9yUG9pbnRlciB8fFxuICAgICAgICAgICAgLy8gLi4uIG9yIGlmIHRoZSBoaXQgb2JqZWN0IGlzIGNhcHR1cmluZyB0aGUgcG9pbnRlclxuICAgICAgICAgICAgY2FwdHVyZXNGb3JQb2ludGVyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHJheWNhc3RFdmVudC5zdG9wcGVkID0gbG9jYWxTdGF0ZS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gUHJvcGFnYXRpb24gaXMgc3RvcHBlZCwgcmVtb3ZlIGFsbCBvdGhlciBob3ZlciByZWNvcmRzXG4gICAgICAgICAgICAgIC8vIEFuIGV2ZW50IGhhbmRsZXIgaXMgb25seSBhbGxvd2VkIHRvIGZsdXNoIG90aGVyIGhhbmRsZXJzIGlmIGl0IGlzIGhvdmVyZWQgaXRzZWxmXG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5ob3ZlcmVkLnNpemUgJiYgQXJyYXkuZnJvbShpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKS5maW5kKGkgPT4gaS5ldmVudE9iamVjdCA9PT0gaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgY2Fubm90IGZsdXNoIG91dCBoaWdoZXIgdXAgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaGVyID0gaW50ZXJzZWN0aW9ucy5zbGljZSgwLCBpbnRlcnNlY3Rpb25zLmluZGV4T2YoaGl0KSk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbLi4uaGlnaGVyLCBoaXRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGwgc3Vic2NyaWJlcnNcbiAgICAgICAgY2FsbGJhY2socmF5Y2FzdEV2ZW50KTtcbiAgICAgICAgLy8gRXZlbnQgYnViYmxpbmcgbWF5IGJlIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvblxuICAgICAgICBpZiAobG9jYWxTdGF0ZS5zdG9wcGVkID09PSB0cnVlKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsUG9pbnRlcihpbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBmb3IgKGNvbnN0IGhvdmVyZWRPYmogb2YgaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkge1xuICAgICAgLy8gV2hlbiBubyBvYmplY3RzIHdlcmUgaGl0IG9yIHRoZSB0aGUgaG92ZXJlZCBvYmplY3Qgd2Fzbid0IGZvdW5kIHVuZGVybmVhdGggdGhlIGN1cnNvclxuICAgICAgLy8gd2UgY2FsbCBvblBvaW50ZXJPdXQgYW5kIGRlbGV0ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGhvdmVyZWQtZWxlbWVudHMgbWFwXG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMubGVuZ3RoIHx8ICFpbnRlcnNlY3Rpb25zLmZpbmQoaGl0ID0+IGhpdC5vYmplY3QgPT09IGhvdmVyZWRPYmoub2JqZWN0ICYmIGhpdC5pbmRleCA9PT0gaG92ZXJlZE9iai5pbmRleCAmJiBoaXQuaW5zdGFuY2VJZCA9PT0gaG92ZXJlZE9iai5pbnN0YW5jZUlkKSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGhvdmVyZWRPYmouZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzO1xuICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShtYWtlSWQoaG92ZXJlZE9iaikpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAuLi5ob3ZlcmVkT2JqLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3V0ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdXQoZGF0YSk7XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNaXNzZWQoZXZlbnQsIG9iamVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0c1tpXS5fX3IzZjtcbiAgICAgIGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXIobmFtZSkge1xuICAgIC8vIERlYWwgd2l0aCBjYW5jZWxhdGlvblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnb25Qb2ludGVyTGVhdmUnOlxuICAgICAgY2FzZSAnb25Qb2ludGVyQ2FuY2VsJzpcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgY2FzZSAnb25Mb3N0UG9pbnRlckNhcHR1cmUnOlxuICAgICAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGV2ZW50IGludGVyZmFjZSBoYWQgb25Mb3N0UG9pbnRlckNhcHR1cmUsIHdlJ2QgY2FsbCBpdCBoZXJlIG9uIGV2ZXJ5XG4gICAgICAgICAgICAvLyBvYmplY3QgdGhhdCdzIGdldHRpbmcgcmVtb3ZlZC4gV2UgY2FsbCBpdCBvbiB0aGUgbmV4dCBmcmFtZSBiZWNhdXNlIG9uTG9zdFBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICAvLyBmaXJlcyBiZWZvcmUgb25Qb2ludGVyVXAuIE90aGVyd2lzZSBwb2ludGVyVXAgd291bGQgbmV2ZXIgYmUgY2FsbGVkIGlmIHRoZSBldmVudCBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGhhcHBlbiBpbiB0aGUgb2JqZWN0IGl0IG9yaWdpbmF0ZWQgZnJvbSwgbGVhdmluZyBjb21wb25lbnRzIGluIGEgaW4tYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcmVsZWFzZSBpZiBwb2ludGVyLXVwIGRpZG4ndCBkbyBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmRlbGV0ZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQW55IG90aGVyIHBvaW50ZXIgZ29lcyBoZXJlIC4uLlxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvblBvaW50ZXJNaXNzZWQsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gcHJlcGFyZVJheShldmVudClcbiAgICAgIGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50ID0gZXZlbnQ7XG5cbiAgICAgIC8vIEdldCBmcmVzaCBpbnRlcnNlY3RzXG4gICAgICBjb25zdCBpc1BvaW50ZXJNb3ZlID0gbmFtZSA9PT0gJ29uUG9pbnRlck1vdmUnO1xuICAgICAgY29uc3QgaXNDbGlja0V2ZW50ID0gbmFtZSA9PT0gJ29uQ2xpY2snIHx8IG5hbWUgPT09ICdvbkNvbnRleHRNZW51JyB8fCBuYW1lID09PSAnb25Eb3VibGVDbGljayc7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBpc1BvaW50ZXJNb3ZlID8gZmlsdGVyUG9pbnRlckV2ZW50cyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGhpdHMgPSBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcik7XG4gICAgICBjb25zdCBkZWx0YSA9IGlzQ2xpY2tFdmVudCA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG5cbiAgICAgIC8vIFNhdmUgaW5pdGlhbCBjb29yZGluYXRlcyBvbiBwb2ludGVyLWRvd25cbiAgICAgIGlmIChuYW1lID09PSAnb25Qb2ludGVyRG93bicpIHtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbENsaWNrID0gW2V2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGhpdHMubWFwKGhpdCA9PiBoaXQuZXZlbnRPYmplY3QpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIGNsaWNrIHlpZWxkcyBubyByZXN1bHRzLCBwYXNzIGl0IGJhY2sgdG8gdGhlIHVzZXIgYXMgYSBtaXNzXG4gICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdCBpbiBvcmRlciB0byBlc3RhYmxpc2ggdXNlci1sYW5kIHNpZGUtZWZmZWN0IGNsZWFuIHVwXG4gICAgICBpZiAoaXNDbGlja0V2ZW50ICYmICFoaXRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGVsdGEgPD0gMikge1xuICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uKTtcbiAgICAgICAgICBpZiAob25Qb2ludGVyTWlzc2VkKSBvblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUYWtlIGNhcmUgb2YgdW5ob3ZlclxuICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIGNhbmNlbFBvaW50ZXIoaGl0cyk7XG4gICAgICBmdW5jdGlvbiBvbkludGVyc2VjdChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2Ugb2YgaGFuZGxlcnNcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSkgcmV0dXJuO1xuXG4gICAgICAgIC8qXG4gICAgICAgIE1BWUJFIFRPRE8sIERFTEVURSBJRiBOT1Q6IFxuICAgICAgICAgIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgY2FwdHVyZWQsIGNhcHR1cmVkIGV2ZW50cyBzaG91bGQgbm90IGhhdmUgaW50ZXJzZWN0cyBydW5uaW5nIGluIHBhcmFsbGVsXG4gICAgICAgICAgQnV0IHdvdWxkbid0IGl0IGJlIGJldHRlciB0byBqdXN0IHJlcGxhY2UgY2FwdHVyZWRNYXAgd2l0aCBhIHNpbmdsZSBlbnRyeT9cbiAgICAgICAgICBBbHNvLCBhcmUgd2UgT0sgd2l0aCBzdHJhaWdodCB1cCBtYWtpbmcgcGlja2luZyB1cCBtdWx0aXBsZSBvYmplY3RzIGltcG9zc2libGU/XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IChkYXRhIGFzIFRocmVlRXZlbnQ8UG9pbnRlckV2ZW50PikucG9pbnRlcklkICAgICAgICBcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZWRNZXNoU2V0ID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KHBvaW50ZXJJZClcbiAgICAgICAgICBpZiAoY2FwdHVyZWRNZXNoU2V0KSB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmVkTWVzaFNldC5nZXQoZXZlbnRPYmplY3QpXG4gICAgICAgICAgICBpZiAoY2FwdHVyZWQgJiYgY2FwdHVyZWQubG9jYWxTdGF0ZS5zdG9wcGVkKSByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSB7XG4gICAgICAgICAgLy8gTW92ZSBldmVudCAuLi5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMub25Qb2ludGVyT3ZlciB8fCBoYW5kbGVycy5vblBvaW50ZXJFbnRlciB8fCBoYW5kbGVycy5vblBvaW50ZXJPdXQgfHwgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW50ZXIgb3Igb3V0IGlzIHByZXNlbnQgdGFrZSBjYXJlIG9mIGhvdmVyLXN0YXRlXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gaW50ZXJuYWwuaG92ZXJlZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhc24ndCBwcmV2aW91c2x5IGhvdmVyZWQsIGJvb2sgaXQgYW5kIGNhbGwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5zZXQoaWQsIGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdmVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdmVyKGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyRW50ZXIoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXMgcHJldmlvdXNseSBob3ZlcmVkIGFuZCBzdG9wcGVkLCB3ZSBzaG91bGRuJ3QgYWxsb3cgb3RoZXIgaXRlbXMgdG8gcHJvY2VlZFxuICAgICAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG1vdXNlIG1vdmVcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJNb3ZlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBldmVudHMgLi4uXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICAgIC8vIE5vdyBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb25Qb2ludGVyTWlzc2VkIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgcG9pbnRlciBvdmVyL291dCBoYW5kbGVycywgYnV0IG5vdCBjbGljayBhbmQgd2VyZW4ndCBoaXRcbiAgICAgICAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCBvbkludGVyc2VjdCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfTtcbn1cblxuLy8gS2V5cyB0aGF0IHNob3VsZG4ndCBiZSBjb3BpZWQgYmV0d2VlbiBSM0Ygc3RvcmVzXG5jb25zdCBwcml2YXRlS2V5cyA9IFsnc2V0JywgJ2dldCcsICdzZXRTaXplJywgJ3NldEZyYW1lbG9vcCcsICdzZXREcHInLCAnZXZlbnRzJywgJ2ludmFsaWRhdGUnLCAnYWR2YW5jZScsICdzaXplJywgJ3ZpZXdwb3J0J107XG5jb25zdCBpc1JlbmRlcmVyID0gZGVmID0+ICEhKGRlZiAhPSBudWxsICYmIGRlZi5yZW5kZXIpO1xuY29uc3QgY29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW52YWxpZGF0ZSwgYWR2YW5jZSkgPT4ge1xuICBjb25zdCByb290U3RhdGUgPSBjcmVhdGUoKHNldCwgZ2V0KSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IGRlZmF1bHRUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IHRlbXBUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEgPSBnZXQoKS5jYW1lcmEsIHRhcmdldCA9IGRlZmF1bHRUYXJnZXQsIHNpemUgPSBnZXQoKS5zaXplKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfSA9IHNpemU7XG4gICAgICBjb25zdCBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzKSB0ZW1wVGFyZ2V0LmNvcHkodGFyZ2V0KTtlbHNlIHRlbXBUYXJnZXQuc2V0KC4uLnRhcmdldCk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5nZXRXb3JsZFBvc2l0aW9uKHBvc2l0aW9uKS5kaXN0YW5jZVRvKHRlbXBUYXJnZXQpO1xuICAgICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvdiA9IGNhbWVyYS5mb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IHZlcnRpY2FsIGZvdiB0byByYWRpYW5zXG4gICAgICAgIGNvbnN0IGggPSAyICogTWF0aC50YW4oZm92IC8gMikgKiBkaXN0YW5jZTsgLy8gdmlzaWJsZSBoZWlnaHRcbiAgICAgICAgY29uc3QgdyA9IGggKiAod2lkdGggLyBoZWlnaHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IHdpZHRoIC8gdyxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBlcmZvcm1hbmNlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzZXRQZXJmb3JtYW5jZUN1cnJlbnQgPSBjdXJyZW50ID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcG9pbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0ge1xuICAgICAgc2V0LFxuICAgICAgZ2V0LFxuICAgICAgLy8gTW9jayBvYmplY3RzIHRoYXQgaGF2ZSB0byBiZSBjb25maWd1cmVkXG4gICAgICBnbDogbnVsbCxcbiAgICAgIGNhbWVyYTogbnVsbCxcbiAgICAgIHJheWNhc3RlcjogbnVsbCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBwcmlvcml0eTogMSxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgY29ubmVjdGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHhyOiBudWxsLFxuICAgICAgc2NlbmU6IG51bGwsXG4gICAgICBpbnZhbGlkYXRlOiAoZnJhbWVzID0gMSkgPT4gaW52YWxpZGF0ZShnZXQoKSwgZnJhbWVzKSxcbiAgICAgIGFkdmFuY2U6ICh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMpID0+IGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzLCBnZXQoKSksXG4gICAgICBsZWdhY3k6IGZhbHNlLFxuICAgICAgbGluZWFyOiBmYWxzZSxcbiAgICAgIGZsYXQ6IGZhbHNlLFxuICAgICAgY29udHJvbHM6IG51bGwsXG4gICAgICBjbG9jazogbmV3IFRIUkVFLkNsb2NrKCksXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICBmcmFtZWxvb3A6ICdhbHdheXMnLFxuICAgICAgb25Qb2ludGVyTWlzc2VkOiB1bmRlZmluZWQsXG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICBjdXJyZW50OiAxLFxuICAgICAgICBtaW46IDAuNSxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICBkZWJvdW5jZTogMjAwLFxuICAgICAgICByZWdyZXNzOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0XG4gICAgICAgICAgaWYgKHBlcmZvcm1hbmNlVGltZW91dCkgY2xlYXJUaW1lb3V0KHBlcmZvcm1hbmNlVGltZW91dCk7XG4gICAgICAgICAgLy8gU2V0IGxvd2VyIGJvdW5kIHBlcmZvcm1hbmNlXG4gICAgICAgICAgaWYgKHN0YXRlLnBlcmZvcm1hbmNlLmN1cnJlbnQgIT09IHN0YXRlLnBlcmZvcm1hbmNlLm1pbikgc2V0UGVyZm9ybWFuY2VDdXJyZW50KHN0YXRlLnBlcmZvcm1hbmNlLm1pbik7XG4gICAgICAgICAgLy8gR28gYmFjayB0byB1cHBlciBib3VuZCBwZXJmb3JtYW5jZSBhZnRlciBhIHdoaWxlIHVubGVzcyBzb21ldGhpbmcgcmVncmVzc2VzIG1lYW53aGlsZVxuICAgICAgICAgIHBlcmZvcm1hbmNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0UGVyZm9ybWFuY2VDdXJyZW50KGdldCgpLnBlcmZvcm1hbmNlLm1heCksIHN0YXRlLnBlcmZvcm1hbmNlLmRlYm91bmNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB1cGRhdGVTdHlsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBpbml0aWFsRHByOiAwLFxuICAgICAgICBkcHI6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYXNwZWN0OiAwLFxuICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgZmFjdG9yOiAwLFxuICAgICAgICBnZXRDdXJyZW50Vmlld3BvcnRcbiAgICAgIH0sXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpLFxuICAgICAgc2V0U2l6ZTogKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlLCB0b3AsIGxlZnQpID0+IHtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gZ2V0KCkuY2FtZXJhO1xuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB0b3A6IHRvcCB8fCAwLFxuICAgICAgICAgIGxlZnQ6IGxlZnQgfHwgMCxcbiAgICAgICAgICB1cGRhdGVTdHlsZVxuICAgICAgICB9O1xuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIC4uLmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIGRlZmF1bHRUYXJnZXQsIHNpemUpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgc2V0RHByOiBkcHIgPT4gc2V0KHN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBjYWxjdWxhdGVEcHIoZHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICBkcHI6IHJlc29sdmVkLFxuICAgICAgICAgICAgaW5pdGlhbERwcjogc3RhdGUudmlld3BvcnQuaW5pdGlhbERwciB8fCByZXNvbHZlZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgc2V0RnJhbWVsb29wOiAoZnJhbWVsb29wID0gJ2Fsd2F5cycpID0+IHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBnZXQoKS5jbG9jaztcblxuICAgICAgICAvLyBpZiBmcmFtZWxvb3AgPT09IFwibmV2ZXJcIiBjbG9jay5lbGFwc2VkVGltZSBpcyB1cGRhdGVkIHVzaW5nIGFkdmFuY2UodGltZXN0YW1wKVxuICAgICAgICBjbG9jay5zdG9wKCk7XG4gICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgaWYgKGZyYW1lbG9vcCAhPT0gJ25ldmVyJykge1xuICAgICAgICAgIGNsb2NrLnN0YXJ0KCk7XG4gICAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNldCgoKSA9PiAoe1xuICAgICAgICAgIGZyYW1lbG9vcFxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgcHJldmlvdXNSb290OiB1bmRlZmluZWQsXG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgZnJhbWVzOiAwLFxuICAgICAgICBsYXN0RXZlbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKSxcbiAgICAgICAgaW50ZXJhY3Rpb246IFtdLFxuICAgICAgICBob3ZlcmVkOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgaW5pdGlhbENsaWNrOiBbMCwgMF0sXG4gICAgICAgIGluaXRpYWxIaXRzOiBbXSxcbiAgICAgICAgY2FwdHVyZWRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlOiAocmVmLCBwcmlvcml0eSwgc3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIHdlIHN3aXRjaCBvZmYgYXV0b21hdGljIHJlbmRlcmluZyBhbmQgaW5jcmVhc2UgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGlzIGZsYWcgaXMgcG9zaXRpdmUgdGhlcmUgY2FuIGJlIG5vIGludGVybmFsIHJlbmRlcmluZyBhdCBhbGxcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHJlbmRlciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSArIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3Vic2NyaWJlciBhbmQgc29ydCBsYXllcnMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgbWVhbmluZyxcbiAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5IHJlbmRlcnMgbGFzdCAob24gdG9wIG9mIHRoZSBvdGhlciBmcmFtZXMpXG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCAmJiBpbnRlcm5hbC5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAvLyBEZWNyZWFzZSBtYW51YWwgZmxhZyBpZiB0aGlzIHN1YnNjcmlwdGlvbiBoYWQgYSBwcmlvcml0eVxuICAgICAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5IC0gKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuZmlsdGVyKHMgPT4gcy5yZWYgIT09IHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJvb3RTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG4gIGxldCBvbGRTaXplID0gc3RhdGUuc2l6ZTtcbiAgbGV0IG9sZERwciA9IHN0YXRlLnZpZXdwb3J0LmRwcjtcbiAgbGV0IG9sZENhbWVyYSA9IHN0YXRlLmNhbWVyYTtcbiAgcm9vdFN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZXJhLFxuICAgICAgc2l6ZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZ2wsXG4gICAgICBzZXRcbiAgICB9ID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBSZXNpemUgY2FtZXJhIGFuZCByZW5kZXJlciBvbiBjaGFuZ2VzIHRvIHNpemUgYW5kIHBpeGVscmF0aW9cbiAgICBpZiAoc2l6ZS53aWR0aCAhPT0gb2xkU2l6ZS53aWR0aCB8fCBzaXplLmhlaWdodCAhPT0gb2xkU2l6ZS5oZWlnaHQgfHwgdmlld3BvcnQuZHByICE9PSBvbGREcHIpIHtcbiAgICAgIHZhciBfc2l6ZSR1cGRhdGVTdHlsZTtcbiAgICAgIG9sZFNpemUgPSBzaXplO1xuICAgICAgb2xkRHByID0gdmlld3BvcnQuZHByO1xuICAgICAgLy8gVXBkYXRlIGNhbWVyYSAmIHJlbmRlcmVyXG4gICAgICB1cGRhdGVDYW1lcmEoY2FtZXJhLCBzaXplKTtcbiAgICAgIGdsLnNldFBpeGVsUmF0aW8odmlld3BvcnQuZHByKTtcbiAgICAgIGNvbnN0IHVwZGF0ZVN0eWxlID0gKF9zaXplJHVwZGF0ZVN0eWxlID0gc2l6ZS51cGRhdGVTdHlsZSkgIT0gbnVsbCA/IF9zaXplJHVwZGF0ZVN0eWxlIDogdHlwZW9mIEhUTUxDYW52YXNFbGVtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBnbC5kb21FbGVtZW50IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQ7XG4gICAgICBnbC5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB1cGRhdGVTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHZpZXdwb3J0IG9uY2UgdGhlIGNhbWVyYSBjaGFuZ2VzXG4gICAgaWYgKGNhbWVyYSAhPT0gb2xkQ2FtZXJhKSB7XG4gICAgICBvbGRDYW1lcmEgPSBjYW1lcmE7XG4gICAgICAvLyBVcGRhdGUgdmlld3BvcnRcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAgIC4uLnN0YXRlLnZpZXdwb3J0LmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEpXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIEludmFsaWRhdGUgb24gYW55IGNoYW5nZVxuICByb290U3RhdGUuc3Vic2NyaWJlKHN0YXRlID0+IGludmFsaWRhdGUoc3RhdGUpKTtcblxuICAvLyBSZXR1cm4gcm9vdCBzdGF0ZVxuICByZXR1cm4gcm9vdFN0YXRlO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlU3VicyhjYWxsYmFjaywgc3Vicykge1xuICBjb25zdCBzdWIgPSB7XG4gICAgY2FsbGJhY2tcbiAgfTtcbiAgc3Vicy5hZGQoc3ViKTtcbiAgcmV0dXJuICgpID0+IHZvaWQgc3Vicy5kZWxldGUoc3ViKTtcbn1cbmxldCBpO1xubGV0IGdsb2JhbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsQWZ0ZXJFZmZlY3RzID0gbmV3IFNldCgpO1xubGV0IGdsb2JhbFRhaWxFZmZlY3RzID0gbmV3IFNldCgpO1xuXG4vKipcbiAqIEFkZHMgYSBnbG9iYWwgcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEVmZmVjdFxuICovXG5jb25zdCBhZGRFZmZlY3QgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxFZmZlY3RzKTtcblxuLyoqXG4gKiBBZGRzIGEgZ2xvYmFsIGFmdGVyLXJlbmRlciBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgZWFjaCBmcmFtZS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRBZnRlckVmZmVjdFxuICovXG5jb25zdCBhZGRBZnRlckVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEFmdGVyRWZmZWN0cyk7XG5cbi8qKlxuICogQWRkcyBhIGdsb2JhbCBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHMuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkVGFpbFxuICovXG5jb25zdCBhZGRUYWlsID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsVGFpbEVmZmVjdHMpO1xuZnVuY3Rpb24gcnVuKGVmZmVjdHMsIHRpbWVzdGFtcCkge1xuICBpZiAoIWVmZmVjdHMuc2l6ZSkgcmV0dXJuO1xuICBmb3IgKGNvbnN0IHtcbiAgICBjYWxsYmFja1xuICB9IG9mIGVmZmVjdHMudmFsdWVzKCkpIHtcbiAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICB9XG59XG5mdW5jdGlvbiBmbHVzaEdsb2JhbEVmZmVjdHModHlwZSwgdGltZXN0YW1wKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JlZm9yZSc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAnYWZ0ZXInOlxuICAgICAgcmV0dXJuIHJ1bihnbG9iYWxBZnRlckVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gICAgY2FzZSAndGFpbCc6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbFRhaWxFZmZlY3RzLCB0aW1lc3RhbXApO1xuICB9XG59XG5sZXQgc3Vic2NyaWJlcnM7XG5sZXQgc3Vic2NyaXB0aW9uO1xuZnVuY3Rpb24gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSwgZnJhbWUpIHtcbiAgLy8gUnVuIGxvY2FsIGVmZmVjdHNcbiAgbGV0IGRlbHRhID0gc3RhdGUuY2xvY2suZ2V0RGVsdGEoKTtcbiAgLy8gSW4gZnJhbWVsb29wPSduZXZlcicgbW9kZSwgY2xvY2sgdGltZXMgYXJlIHVwZGF0ZWQgdXNpbmcgdGhlIHByb3ZpZGVkIHRpbWVzdGFtcFxuICBpZiAoc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInICYmIHR5cGVvZiB0aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgZGVsdGEgPSB0aW1lc3RhbXAgLSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5vbGRUaW1lID0gc3RhdGUuY2xvY2suZWxhcHNlZFRpbWU7XG4gICAgc3RhdGUuY2xvY2suZWxhcHNlZFRpbWUgPSB0aW1lc3RhbXA7XG4gIH1cbiAgLy8gQ2FsbCBzdWJzY3JpYmVycyAodXNlRnJhbWUpXG4gIHN1YnNjcmliZXJzID0gc3RhdGUuaW50ZXJuYWwuc3Vic2NyaWJlcnM7XG4gIGZvciAoaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkrKykge1xuICAgIHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZXJzW2ldO1xuICAgIHN1YnNjcmlwdGlvbi5yZWYuY3VycmVudChzdWJzY3JpcHRpb24uc3RvcmUuZ2V0U3RhdGUoKSwgZGVsdGEsIGZyYW1lKTtcbiAgfVxuICAvLyBSZW5kZXIgY29udGVudFxuICBpZiAoIXN0YXRlLmludGVybmFsLnByaW9yaXR5ICYmIHN0YXRlLmdsLnJlbmRlcikgc3RhdGUuZ2wucmVuZGVyKHN0YXRlLnNjZW5lLCBzdGF0ZS5jYW1lcmEpO1xuICAvLyBEZWNyZWFzZSBmcmFtZSBjb3VudFxuICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1heCgwLCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgLSAxKTtcbiAgcmV0dXJuIHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgPyAxIDogc3RhdGUuaW50ZXJuYWwuZnJhbWVzO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9vcChyb290cykge1xuICBsZXQgcnVubmluZyA9IGZhbHNlO1xuICBsZXQgcmVwZWF0O1xuICBsZXQgZnJhbWU7XG4gIGxldCBzdGF0ZTtcbiAgZnVuY3Rpb24gbG9vcCh0aW1lc3RhbXApIHtcbiAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICByZXBlYXQgPSAwO1xuXG4gICAgLy8gUnVuIGVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBSZW5kZXIgYWxsIHJvb3RzXG4gICAgZm9yIChjb25zdCByb290IG9mIHJvb3RzLnZhbHVlcygpKSB7XG4gICAgICB2YXIgX3N0YXRlJGdsJHhyO1xuICAgICAgc3RhdGUgPSByb290LnN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAvLyBJZiB0aGUgZnJhbWVsb29wIGlzIGludmFsaWRhdGVkLCBkbyBub3QgcnVuIGFub3RoZXIgZnJhbWVcbiAgICAgIGlmIChzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgJiYgKHN0YXRlLmZyYW1lbG9vcCA9PT0gJ2Fsd2F5cycgfHwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID4gMCkgJiYgISgoX3N0YXRlJGdsJHhyID0gc3RhdGUuZ2wueHIpICE9IG51bGwgJiYgX3N0YXRlJGdsJHhyLmlzUHJlc2VudGluZykpIHtcbiAgICAgICAgcmVwZWF0ICs9IHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1biBhZnRlci1lZmZlY3RzXG4gICAgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG5cbiAgICAvLyBTdG9wIHRoZSBsb29wIGlmIG5vdGhpbmcgaW52YWxpZGF0ZXMgaXRcbiAgICBpZiAocmVwZWF0ID09PSAwKSB7XG4gICAgICAvLyBUYWlsIGNhbGwgZWZmZWN0cywgdGhleSBhcmUgY2FsbGVkIHdoZW4gcmVuZGVyaW5nIHN0b3BzXG4gICAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ3RhaWwnLCB0aW1lc3RhbXApO1xuXG4gICAgICAvLyBGbGFnIGVuZCBvZiBvcGVyYXRpb25cbiAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGludmFsaWRhdGUoc3RhdGUsIGZyYW1lcyA9IDEpIHtcbiAgICB2YXIgX3N0YXRlJGdsJHhyMjtcbiAgICBpZiAoIXN0YXRlKSByZXR1cm4gcm9vdHMuZm9yRWFjaChyb290ID0+IGludmFsaWRhdGUocm9vdC5zdG9yZS5nZXRTdGF0ZSgpKSwgZnJhbWVzKTtcbiAgICBpZiAoKF9zdGF0ZSRnbCR4cjIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIyLmlzUHJlc2VudGluZyB8fCAhc3RhdGUuaW50ZXJuYWwuYWN0aXZlIHx8IHN0YXRlLmZyYW1lbG9vcCA9PT0gJ25ldmVyJykgcmV0dXJuO1xuICAgIC8vIEluY3JlYXNlIGZyYW1lcywgZG8gbm90IGdvIGhpZ2hlciB0aGFuIDYwXG4gICAgc3RhdGUuaW50ZXJuYWwuZnJhbWVzID0gTWF0aC5taW4oNjAsIHN0YXRlLmludGVybmFsLmZyYW1lcyArIGZyYW1lcyk7XG4gICAgLy8gSWYgdGhlIHJlbmRlci1sb29wIGlzbid0IGFjdGl2ZSwgc3RhcnQgaXRcbiAgICBpZiAoIXJ1bm5pbmcpIHtcbiAgICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZHZhbmNlKHRpbWVzdGFtcCwgcnVuR2xvYmFsRWZmZWN0cyA9IHRydWUsIHN0YXRlLCBmcmFtZSkge1xuICAgIGlmIChydW5HbG9iYWxFZmZlY3RzKSBmbHVzaEdsb2JhbEVmZmVjdHMoJ2JlZm9yZScsIHRpbWVzdGFtcCk7XG4gICAgaWYgKCFzdGF0ZSkgZm9yIChjb25zdCByb290IG9mIHJvb3RzLnZhbHVlcygpKSByZW5kZXIkMSh0aW1lc3RhbXAsIHJvb3Quc3RvcmUuZ2V0U3RhdGUoKSk7ZWxzZSByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSk7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYWZ0ZXInLCB0aW1lc3RhbXApO1xuICB9XG4gIHJldHVybiB7XG4gICAgbG9vcCxcbiAgICAvKipcbiAgICAgKiBJbnZhbGlkYXRlcyB0aGUgdmlldywgcmVxdWVzdGluZyBhIGZyYW1lIHRvIGJlIHJlbmRlcmVkLiBXaWxsIGdsb2JhbGx5IGludmFsaWRhdGUgdW5sZXNzIHBhc3NlZCBhIHJvb3QncyBzdGF0ZS5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjaW52YWxpZGF0ZVxuICAgICAqL1xuICAgIGludmFsaWRhdGUsXG4gICAgLyoqXG4gICAgICogQWR2YW5jZXMgdGhlIGZyYW1lbG9vcCBhbmQgcnVucyByZW5kZXIgZWZmZWN0cywgdXNlZnVsIGZvciB3aGVuIG1hbnVhbGx5IHJlbmRlcmluZyB2aWEgYGZyYW1lbG9vcD1cIm5ldmVyXCJgLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZHZhbmNlXG4gICAgICovXG4gICAgYWR2YW5jZVxuICB9O1xufVxuXG4vKipcbiAqIEV4cG9zZXMgYW4gb2JqZWN0J3Mge0BsaW5rIExvY2FsU3RhdGV9LlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI3VzZUluc3RhbmNlSGFuZGxlXG4gKlxuICogKipOb3RlKio6IHRoaXMgaXMgYW4gZXNjYXBlIGhhdGNoIHRvIHJlYWN0LWludGVybmFsIGZpZWxkcy4gRXhwZWN0IHRoaXMgdG8gY2hhbmdlIHNpZ25pZmljYW50bHkgYmV0d2VlbiB2ZXJzaW9ucy5cbiAqL1xuZnVuY3Rpb24gdXNlSW5zdGFuY2VIYW5kbGUocmVmKSB7XG4gIGNvbnN0IGluc3RhbmNlID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKGluc3RhbmNlLmN1cnJlbnQgPSByZWYuY3VycmVudC5fX3IzZiksIFtyZWZdKTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlU3RvcmUoKSB7XG4gIGNvbnN0IHN0b3JlID0gUmVhY3QudXNlQ29udGV4dChjb250ZXh0KTtcbiAgaWYgKCFzdG9yZSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IEhvb2tzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aGluIHRoZSBDYW52YXMgY29tcG9uZW50IScpO1xuICByZXR1cm4gc3RvcmU7XG59XG5cbi8qKlxuICogQWNjZXNzZXMgUjNGJ3MgaW50ZXJuYWwgc3RhdGUsIGNvbnRhaW5pbmcgcmVuZGVyZXIsIGNhbnZhcywgc2NlbmUsIGV0Yy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZXRocmVlXG4gKi9cbmZ1bmN0aW9uIHVzZVRocmVlKHNlbGVjdG9yID0gc3RhdGUgPT4gc3RhdGUsIGVxdWFsaXR5Rm4pIHtcbiAgcmV0dXJuIHVzZVN0b3JlKCkoc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgYmVmb3JlIHJlbmRlciBpbiBhIHNoYXJlZCBmcmFtZSBsb29wLlxuICogQ2FuIG9yZGVyIGVmZmVjdHMgd2l0aCByZW5kZXIgcHJpb3JpdHkgb3IgbWFudWFsbHkgcmVuZGVyIHdpdGggYSBwb3NpdGl2ZSBwcmlvcml0eS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWZyYW1lXG4gKi9cbmZ1bmN0aW9uIHVzZUZyYW1lKGNhbGxiYWNrLCByZW5kZXJQcmlvcml0eSA9IDApIHtcbiAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZSgpO1xuICBjb25zdCBzdWJzY3JpYmUgPSBzdG9yZS5nZXRTdGF0ZSgpLmludGVybmFsLnN1YnNjcmliZTtcbiAgLy8gTWVtb2l6ZSByZWZcbiAgY29uc3QgcmVmID0gdXNlTXV0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgLy8gU3Vic2NyaWJlIG9uIG1vdW50LCB1bnN1YnNjcmliZSBvbiB1bm1vdW50XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gc3Vic2NyaWJlKHJlZiwgcmVuZGVyUHJpb3JpdHksIHN0b3JlKSwgW3JlbmRlclByaW9yaXR5LCBzdWJzY3JpYmUsIHN0b3JlXSk7XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBub2RlIGdyYXBoIG9mIGFuIG9iamVjdCB3aXRoIG5hbWVkIG5vZGVzICYgbWF0ZXJpYWxzLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZ3JhcGhcbiAqL1xuZnVuY3Rpb24gdXNlR3JhcGgob2JqZWN0KSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGJ1aWxkR3JhcGgob2JqZWN0KSwgW29iamVjdF0pO1xufVxuY29uc3QgbWVtb2l6ZWRMb2FkZXJzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoUHJvdG8sIC4uLmlucHV0KSB7XG4gICAgLy8gQ29uc3RydWN0IG5ldyBsb2FkZXIgYW5kIHJ1biBleHRlbnNpb25zXG4gICAgbGV0IGxvYWRlciA9IG1lbW9pemVkTG9hZGVycy5nZXQoUHJvdG8pO1xuICAgIGlmICghbG9hZGVyKSB7XG4gICAgICBsb2FkZXIgPSBuZXcgUHJvdG8oKTtcbiAgICAgIG1lbW9pemVkTG9hZGVycy5zZXQoUHJvdG8sIGxvYWRlcik7XG4gICAgfVxuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gICAgLy8gR28gdGhyb3VnaCB0aGUgdXJscyBhbmQgbG9hZCB0aGVtXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGlucHV0Lm1hcChpbnB1dCA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IGxvYWRlci5sb2FkKGlucHV0LCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnNjZW5lKSBPYmplY3QuYXNzaWduKGRhdGEsIGJ1aWxkR3JhcGgoZGF0YS5zY2VuZSkpO1xuICAgICAgcmVzKGRhdGEpO1xuICAgIH0sIG9uUHJvZ3Jlc3MsIGVycm9yID0+IHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkICR7aW5wdXR9OiAke2Vycm9yID09IG51bGwgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlfWApKSkpKSkuZmluYWxseSgoKSA9PiBsb2FkZXIuZGlzcG9zZSA9PSBudWxsID8gdm9pZCAwIDogbG9hZGVyLmRpc3Bvc2UoKSk7XG4gIH07XG59XG4vKipcbiAqIFN5bmNocm9ub3VzbHkgbG9hZHMgYW5kIGNhY2hlcyBhc3NldHMgd2l0aCBhIHRocmVlIGxvYWRlci5cbiAqXG4gKiBOb3RlOiB0aGlzIGhvb2sncyBjYWxsZXIgbXVzdCBiZSB3cmFwcGVkIHdpdGggYFJlYWN0LlN1c3BlbnNlYFxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlbG9hZGVyXG4gKi9cbmZ1bmN0aW9uIHVzZUxvYWRlcihQcm90bywgaW5wdXQsIGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpIHtcbiAgLy8gVXNlIHN1c3BlbnNlIHRvIGxvYWQgYXN5bmMgYXNzZXRzXG4gIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGlucHV0KSA/IGlucHV0IDogW2lucHV0XTtcbiAgY29uc3QgcmVzdWx0cyA9IHN1c3BlbmQobG9hZGluZ0ZuKGV4dGVuc2lvbnMsIG9uUHJvZ3Jlc3MpLCBbUHJvdG8sIC4uLmtleXNdLCB7XG4gICAgZXF1YWw6IGlzLmVxdVxuICB9KTtcbiAgLy8gUmV0dXJuIHRoZSBvYmplY3Qvc1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dCkgPyByZXN1bHRzIDogcmVzdWx0c1swXTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkcyBhbiBhc3NldCBpbnRvIGNhY2hlIGFzIGEgc2lkZS1lZmZlY3QuXG4gKi9cbnVzZUxvYWRlci5wcmVsb2FkID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCwgZXh0ZW5zaW9ucykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBwcmVsb2FkKGxvYWRpbmdGbihleHRlbnNpb25zKSwgW1Byb3RvLCAuLi5rZXlzXSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBsb2FkZWQgYXNzZXQgZnJvbSBjYWNoZS5cbiAqL1xudXNlTG9hZGVyLmNsZWFyID0gZnVuY3Rpb24gKFByb3RvLCBpbnB1dCkge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIHJldHVybiBjbGVhcihbUHJvdG8sIC4uLmtleXNdKTtcbn07XG5cbmNvbnN0IHJvb3RzID0gbmV3IE1hcCgpO1xuY29uc3Qge1xuICBpbnZhbGlkYXRlLFxuICBhZHZhbmNlXG59ID0gY3JlYXRlTG9vcChyb290cyk7XG5jb25zdCB7XG4gIHJlY29uY2lsZXIsXG4gIGFwcGx5UHJvcHNcbn0gPSBjcmVhdGVSZW5kZXJlcihyb290cywgZ2V0RXZlbnRQcmlvcml0eSk7XG5jb25zdCBzaGFsbG93TG9vc2UgPSB7XG4gIG9iamVjdHM6ICdzaGFsbG93JyxcbiAgc3RyaWN0OiBmYWxzZVxufTtcbmNvbnN0IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UgPSAoZ2wsIGNhbnZhcykgPT4ge1xuICBjb25zdCBjdXN0b21SZW5kZXJlciA9IHR5cGVvZiBnbCA9PT0gJ2Z1bmN0aW9uJyA/IGdsKGNhbnZhcykgOiBnbDtcbiAgaWYgKGlzUmVuZGVyZXIoY3VzdG9tUmVuZGVyZXIpKSByZXR1cm4gY3VzdG9tUmVuZGVyZXI7ZWxzZSByZXR1cm4gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoe1xuICAgIHBvd2VyUHJlZmVyZW5jZTogJ2hpZ2gtcGVyZm9ybWFuY2UnLFxuICAgIGNhbnZhczogY2FudmFzLFxuICAgIGFudGlhbGlhczogdHJ1ZSxcbiAgICBhbHBoYTogdHJ1ZSxcbiAgICAuLi5nbFxuICB9KTtcbn07XG5mdW5jdGlvbiBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBkZWZhdWx0U2l6ZSkge1xuICBjb25zdCBkZWZhdWx0U3R5bGUgPSB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50O1xuICBpZiAoZGVmYXVsdFNpemUpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICB1cGRhdGVTdHlsZSA9IGRlZmF1bHRTdHlsZVxuICAgIH0gPSBkZWZhdWx0U2l6ZTtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0LFxuICAgICAgdXBkYXRlU3R5bGVcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9ID0gY2FudmFzLnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgbGVmdCxcbiAgICAgIHVwZGF0ZVN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIHVwZGF0ZVN0eWxlOiBkZWZhdWx0U3R5bGVcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb290KGNhbnZhcykge1xuICAvLyBDaGVjayBhZ2FpbnN0IG1pc3Rha2VuIHVzZSBvZiBjcmVhdGVSb290XG4gIGNvbnN0IHByZXZSb290ID0gcm9vdHMuZ2V0KGNhbnZhcyk7XG4gIGNvbnN0IHByZXZGaWJlciA9IHByZXZSb290ID09IG51bGwgPyB2b2lkIDAgOiBwcmV2Um9vdC5maWJlcjtcbiAgY29uc3QgcHJldlN0b3JlID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LnN0b3JlO1xuICBpZiAocHJldlJvb3QpIGNvbnNvbGUud2FybignUjNGLmNyZWF0ZVJvb3Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UhJyk7XG5cbiAgLy8gUmVwb3J0IHdoZW4gYW4gZXJyb3Igd2FzIGRldGVjdGVkIGluIGEgcHJldmlvdXMgcmVuZGVyXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yMjYxXG4gIGNvbnN0IGxvZ1JlY292ZXJhYmxlRXJyb3IgPSB0eXBlb2YgcmVwb3J0RXJyb3IgPT09ICdmdW5jdGlvbicgP1xuICAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMsIHJlcG9ydEVycm9yIHdpbGwgZGlzcGF0Y2ggYW4gZXJyb3IgZXZlbnQsXG4gIC8vIGVtdWxhdGluZyBhbiB1bmNhdWdodCBKYXZhU2NyaXB0IGVycm9yLlxuICByZXBvcnRFcnJvciA6XG4gIC8vIEluIG9sZGVyIGJyb3dzZXJzIGFuZCB0ZXN0IGVudmlyb25tZW50cywgZmFsbGJhY2sgdG8gY29uc29sZS5lcnJvci5cbiAgY29uc29sZS5lcnJvcjtcblxuICAvLyBDcmVhdGUgc3RvcmVcbiAgY29uc3Qgc3RvcmUgPSBwcmV2U3RvcmUgfHwgY3JlYXRlU3RvcmUoaW52YWxpZGF0ZSwgYWR2YW5jZSk7XG4gIC8vIENyZWF0ZSByZW5kZXJlclxuICBjb25zdCBmaWJlciA9IHByZXZGaWJlciB8fCByZWNvbmNpbGVyLmNyZWF0ZUNvbnRhaW5lcihzdG9yZSwgQ29uY3VycmVudFJvb3QsIG51bGwsIGZhbHNlLCBudWxsLCAnJywgbG9nUmVjb3ZlcmFibGVFcnJvciwgbnVsbCk7XG4gIC8vIE1hcCBpdFxuICBpZiAoIXByZXZSb290KSByb290cy5zZXQoY2FudmFzLCB7XG4gICAgZmliZXIsXG4gICAgc3RvcmVcbiAgfSk7XG5cbiAgLy8gTG9jYWxzXG4gIGxldCBvbkNyZWF0ZWQ7XG4gIGxldCBjb25maWd1cmVkID0gZmFsc2U7XG4gIGxldCBsYXN0Q2FtZXJhO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyZShwcm9wcyA9IHt9KSB7XG4gICAgICBsZXQge1xuICAgICAgICBnbDogZ2xDb25maWcsXG4gICAgICAgIHNpemU6IHByb3BzU2l6ZSxcbiAgICAgICAgc2NlbmU6IHNjZW5lT3B0aW9ucyxcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZENhbGxiYWNrLFxuICAgICAgICBzaGFkb3dzID0gZmFsc2UsXG4gICAgICAgIGxpbmVhciA9IGZhbHNlLFxuICAgICAgICBmbGF0ID0gZmFsc2UsXG4gICAgICAgIGxlZ2FjeSA9IGZhbHNlLFxuICAgICAgICBvcnRob2dyYXBoaWMgPSBmYWxzZSxcbiAgICAgICAgZnJhbWVsb29wID0gJ2Fsd2F5cycsXG4gICAgICAgIGRwciA9IFsxLCAyXSxcbiAgICAgICAgcGVyZm9ybWFuY2UsXG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdE9wdGlvbnMsXG4gICAgICAgIGNhbWVyYTogY2FtZXJhT3B0aW9ucyxcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkXG4gICAgICB9ID0gcHJvcHM7XG4gICAgICBsZXQgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZXQgdXAgcmVuZGVyZXIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgbGV0IGdsID0gc3RhdGUuZ2w7XG4gICAgICBpZiAoIXN0YXRlLmdsKSBzdGF0ZS5zZXQoe1xuICAgICAgICBnbDogZ2wgPSBjcmVhdGVSZW5kZXJlckluc3RhbmNlKGdsQ29uZmlnLCBjYW52YXMpXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHVwIHJheWNhc3RlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgcmF5Y2FzdGVyID0gc3RhdGUucmF5Y2FzdGVyO1xuICAgICAgaWYgKCFyYXljYXN0ZXIpIHN0YXRlLnNldCh7XG4gICAgICAgIHJheWNhc3RlcjogcmF5Y2FzdGVyID0gbmV3IFRIUkVFLlJheWNhc3RlcigpXG4gICAgICB9KTtcblxuICAgICAgLy8gU2V0IHJheWNhc3RlciBvcHRpb25zXG4gICAgICBjb25zdCB7XG4gICAgICAgIHBhcmFtcyxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSA9IHJheWNhc3RPcHRpb25zIHx8IHt9O1xuICAgICAgaWYgKCFpcy5lcXUob3B0aW9ucywgcmF5Y2FzdGVyLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICAgIGlmICghaXMuZXF1KHBhcmFtcywgcmF5Y2FzdGVyLnBhcmFtcywgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhyYXljYXN0ZXIsIHtcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgLi4ucmF5Y2FzdGVyLnBhcmFtcyxcbiAgICAgICAgICAuLi5wYXJhbXNcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGNhbWVyYSwgZG9uJ3Qgb3ZlcndyaXRlIGFueSB1c2VyLXNldCBzdGF0ZVxuICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgfHwgc3RhdGUuY2FtZXJhID09PSBsYXN0Q2FtZXJhICYmICFpcy5lcXUobGFzdENhbWVyYSwgY2FtZXJhT3B0aW9ucywgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBsYXN0Q2FtZXJhID0gY2FtZXJhT3B0aW9ucztcbiAgICAgICAgY29uc3QgaXNDYW1lcmEgPSBjYW1lcmFPcHRpb25zIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhO1xuICAgICAgICBjb25zdCBjYW1lcmEgPSBpc0NhbWVyYSA/IGNhbWVyYU9wdGlvbnMgOiBvcnRob2dyYXBoaWMgPyBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKDAsIDAsIDAsIDAsIDAuMSwgMTAwMCkgOiBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoNzUsIDAsIDAuMSwgMTAwMCk7XG4gICAgICAgIGlmICghaXNDYW1lcmEpIHtcbiAgICAgICAgICBjYW1lcmEucG9zaXRpb24ueiA9IDU7XG4gICAgICAgICAgaWYgKGNhbWVyYU9wdGlvbnMpIGFwcGx5UHJvcHMoY2FtZXJhLCBjYW1lcmFPcHRpb25zKTtcbiAgICAgICAgICAvLyBBbHdheXMgbG9vayBhdCBjZW50ZXIgYnkgZGVmYXVsdFxuICAgICAgICAgIGlmICghc3RhdGUuY2FtZXJhICYmICEoY2FtZXJhT3B0aW9ucyAhPSBudWxsICYmIGNhbWVyYU9wdGlvbnMucm90YXRpb24pKSBjYW1lcmEubG9va0F0KDAsIDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgY2FtZXJhXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbmZpZ3VyZSByYXljYXN0ZXJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC14ci9pc3N1ZXMvMzAwXG4gICAgICAgIHJheWNhc3Rlci5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBzY2VuZSAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnNjZW5lKSB7XG4gICAgICAgIGxldCBzY2VuZTtcbiAgICAgICAgaWYgKHNjZW5lT3B0aW9ucyBpbnN0YW5jZW9mIFRIUkVFLlNjZW5lKSB7XG4gICAgICAgICAgc2NlbmUgPSBzY2VuZU9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgICAgICBpZiAoc2NlbmVPcHRpb25zKSBhcHBseVByb3BzKHNjZW5lLCBzY2VuZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgc2NlbmU6IHByZXBhcmUoc2NlbmUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgWFIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS54cikge1xuICAgICAgICB2YXIgX2dsJHhyO1xuICAgICAgICAvLyBIYW5kbGUgZnJhbWUgYmVoYXZpb3IgaW4gV2ViWFJcbiAgICAgICAgY29uc3QgaGFuZGxlWFJGcmFtZSA9ICh0aW1lc3RhbXAsIGZyYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICAgICAgICBhZHZhbmNlKHRpbWVzdGFtcCwgdHJ1ZSwgc3RhdGUsIGZyYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUb2dnbGUgcmVuZGVyIHN3aXRjaGluZyBvbiBzZXNzaW9uXG4gICAgICAgIGNvbnN0IGhhbmRsZVNlc3Npb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLmVuYWJsZWQgPSBzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmc7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuc2V0QW5pbWF0aW9uTG9vcChzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcgPyBoYW5kbGVYUkZyYW1lIDogbnVsbCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcpIGludmFsaWRhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdlYlhSIHNlc3Npb24gbWFuYWdlclxuICAgICAgICBjb25zdCB4ciA9IHtcbiAgICAgICAgICBjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJYUiBzZXNzaW9uIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mICgoX2dsJHhyID0gZ2wueHIpID09IG51bGwgPyB2b2lkIDAgOiBfZ2wkeHIuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHhyLmNvbm5lY3QoKTtcbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICB4clxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHNoYWRvd21hcFxuICAgICAgaWYgKGdsLnNoYWRvd01hcCkge1xuICAgICAgICBjb25zdCBvbGRFbmFibGVkID0gZ2wuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgICAgIGNvbnN0IG9sZFR5cGUgPSBnbC5zaGFkb3dNYXAudHlwZTtcbiAgICAgICAgZ2wuc2hhZG93TWFwLmVuYWJsZWQgPSAhIXNoYWRvd3M7XG4gICAgICAgIGlmIChpcy5ib28oc2hhZG93cykpIHtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc3RyKHNoYWRvd3MpKSB7XG4gICAgICAgICAgdmFyIF90eXBlcyRzaGFkb3dzO1xuICAgICAgICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICAgICAgYmFzaWM6IFRIUkVFLkJhc2ljU2hhZG93TWFwLFxuICAgICAgICAgICAgcGVyY2VudGFnZTogVEhSRUUuUENGU2hhZG93TWFwLFxuICAgICAgICAgICAgc29mdDogVEhSRUUuUENGU29mdFNoYWRvd01hcCxcbiAgICAgICAgICAgIHZhcmlhbmNlOiBUSFJFRS5WU01TaGFkb3dNYXBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gKF90eXBlcyRzaGFkb3dzID0gdHlwZXNbc2hhZG93c10pICE9IG51bGwgPyBfdHlwZXMkc2hhZG93cyA6IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMub2JqKHNoYWRvd3MpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihnbC5zaGFkb3dNYXAsIHNoYWRvd3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRFbmFibGVkICE9PSBnbC5zaGFkb3dNYXAuZW5hYmxlZCB8fCBvbGRUeXBlICE9PSBnbC5zaGFkb3dNYXAudHlwZSkgZ2wuc2hhZG93TWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2FmZWx5IHNldCBjb2xvciBtYW5hZ2VtZW50IGlmIGF2YWlsYWJsZS5cbiAgICAgIC8vIEF2b2lkIGFjY2Vzc2luZyBUSFJFRS5Db2xvck1hbmFnZW1lbnQgdG8gcGxheSBuaWNlIHdpdGggb2xkZXIgdmVyc2lvbnNcbiAgICAgIGNvbnN0IENvbG9yTWFuYWdlbWVudCA9IGdldENvbG9yTWFuYWdlbWVudCgpO1xuICAgICAgaWYgKENvbG9yTWFuYWdlbWVudCkge1xuICAgICAgICBpZiAoJ2VuYWJsZWQnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPSAhbGVnYWN5O2Vsc2UgaWYgKCdsZWdhY3lNb2RlJyBpbiBDb2xvck1hbmFnZW1lbnQpIENvbG9yTWFuYWdlbWVudC5sZWdhY3lNb2RlID0gbGVnYWN5O1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzXG4gICAgICBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG4gICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgYXBwbHlQcm9wcyhnbCwge1xuICAgICAgICBvdXRwdXRFbmNvZGluZzogbGluZWFyID8gTGluZWFyRW5jb2RpbmcgOiBzUkdCRW5jb2RpbmcsXG4gICAgICAgIHRvbmVNYXBwaW5nOiBmbGF0ID8gVEhSRUUuTm9Ub25lTWFwcGluZyA6IFRIUkVFLkFDRVNGaWxtaWNUb25lTWFwcGluZ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xvciBtYW5hZ2VtZW50IHN0YXRlXG4gICAgICBpZiAoc3RhdGUubGVnYWN5ICE9PSBsZWdhY3kpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsZWdhY3lcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5saW5lYXIgIT09IGxpbmVhcikgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxpbmVhclxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmZsYXQgIT09IGZsYXQpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBmbGF0XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBnbCBwcm9wc1xuICAgICAgaWYgKGdsQ29uZmlnICYmICFpcy5mdW4oZ2xDb25maWcpICYmICFpc1JlbmRlcmVyKGdsQ29uZmlnKSAmJiAhaXMuZXF1KGdsQ29uZmlnLCBnbCwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhnbCwgZ2xDb25maWcpO1xuICAgICAgLy8gU3RvcmUgZXZlbnRzIGludGVybmFsbHlcbiAgICAgIGlmIChldmVudHMgJiYgIXN0YXRlLmV2ZW50cy5oYW5kbGVycykgc3RhdGUuc2V0KHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMoc3RvcmUpXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHNpemUsIGFsbG93IGl0IHRvIHRha2Ugb24gY29udGFpbmVyIGJvdW5kcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IHNpemUgPSBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBwcm9wc1NpemUpO1xuICAgICAgaWYgKCFpcy5lcXUoc2l6ZSwgc3RhdGUuc2l6ZSwgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBzdGF0ZS5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBzaXplLnVwZGF0ZVN0eWxlLCBzaXplLnRvcCwgc2l6ZS5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHBpeGVscmF0aW9cbiAgICAgIGlmIChkcHIgJiYgc3RhdGUudmlld3BvcnQuZHByICE9PSBjYWxjdWxhdGVEcHIoZHByKSkgc3RhdGUuc2V0RHByKGRwcik7XG4gICAgICAvLyBDaGVjayBmcmFtZWxvb3BcbiAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgIT09IGZyYW1lbG9vcCkgc3RhdGUuc2V0RnJhbWVsb29wKGZyYW1lbG9vcCk7XG4gICAgICAvLyBDaGVjayBwb2ludGVyIG1pc3NlZFxuICAgICAgaWYgKCFzdGF0ZS5vblBvaW50ZXJNaXNzZWQpIHN0YXRlLnNldCh7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZVxuICAgICAgaWYgKHBlcmZvcm1hbmNlICYmICFpcy5lcXUocGVyZm9ybWFuY2UsIHN0YXRlLnBlcmZvcm1hbmNlLCBzaGFsbG93TG9vc2UpKSBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAuLi5wZXJmb3JtYW5jZVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBsb2NhbHNcbiAgICAgIG9uQ3JlYXRlZCA9IG9uQ3JlYXRlZENhbGxiYWNrO1xuICAgICAgY29uZmlndXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbmRlcihjaGlsZHJlbikge1xuICAgICAgLy8gVGhlIHJvb3QgaGFzIHRvIGJlIGNvbmZpZ3VyZWQgYmVmb3JlIGl0IGNhbiBiZSByZW5kZXJlZFxuICAgICAgaWYgKCFjb25maWd1cmVkKSB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZCxcbiAgICAgICAgcm9vdEVsZW1lbnQ6IGNhbnZhc1xuICAgICAgfSksIGZpYmVyLCBudWxsLCAoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXIoY2hpbGRyZW4sIGNhbnZhcywgY29uZmlnKSB7XG4gIGNvbnNvbGUud2FybignUjNGLnJlbmRlciBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGluIFJlYWN0IDE4LiBVc2UgY3JlYXRlUm9vdCBpbnN0ZWFkIScpO1xuICBjb25zdCByb290ID0gY3JlYXRlUm9vdChjYW52YXMpO1xuICByb290LmNvbmZpZ3VyZShjb25maWcpO1xuICByZXR1cm4gcm9vdC5yZW5kZXIoY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY2hpbGRyZW4sXG4gIG9uQ3JlYXRlZCxcbiAgcm9vdEVsZW1lbnRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIEZsYWcgdGhlIGNhbnZhcyBhY3RpdmUsIHJlbmRlcmluZyB3aWxsIG5vdyBiZWdpblxuICAgIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJuYWwsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pKTtcbiAgICAvLyBOb3RpZml5IHRoYXQgaW5pdCBpcyBjb21wbGV0ZWQsIHRoZSBzY2VuZSBncmFwaCBleGlzdHMsIGJ1dCBub3RoaW5nIGhhcyB5ZXQgcmVuZGVyZWRcbiAgICBpZiAob25DcmVhdGVkKSBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgIC8vIENvbm5lY3QgZXZlbnRzIHRvIHRoZSB0YXJnZXRzIHBhcmVudCwgdGhpcyBpcyBkb25lIHRvIGVuc3VyZSBldmVudHMgYXJlIHJlZ2lzdGVyZWQgb25cbiAgICAvLyBhIHNoYXJlZCB0YXJnZXQsIGFuZCBub3Qgb24gdGhlIGNhbnZhcyBpdHNlbGZcbiAgICBpZiAoIXN0b3JlLmdldFN0YXRlKCkuZXZlbnRzLmNvbm5lY3RlZCkgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KHJvb3RFbGVtZW50KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmVcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgZmliZXIgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmZpYmVyO1xuICBpZiAoZmliZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUpIHN0YXRlLmludGVybmFsLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIGZpYmVyLCBudWxsLCAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc3RhdGUkZ2wsIF9zdGF0ZSRnbCRyZW5kZXJMaXN0cywgX3N0YXRlJGdsMiwgX3N0YXRlJGdsMztcbiAgICAgICAgICAgIHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbCA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogKF9zdGF0ZSRnbCRyZW5kZXJMaXN0cyA9IF9zdGF0ZSRnbC5yZW5kZXJMaXN0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbDIgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcyA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzKCk7XG4gICAgICAgICAgICBpZiAoKF9zdGF0ZSRnbDMgPSBzdGF0ZS5nbCkgIT0gbnVsbCAmJiBfc3RhdGUkZ2wzLnhyKSBzdGF0ZS54ci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkaXNwb3NlKHN0YXRlKTtcbiAgICAgICAgICAgIHJvb3RzLmRlbGV0ZShjYW52YXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhjYW52YXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIHN0YXRlKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWwsIHtcbiAgICBrZXk6IGNvbnRhaW5lci51dWlkLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBQb3J0YWwoe1xuICBzdGF0ZSA9IHt9LFxuICBjaGlsZHJlbixcbiAgY29udGFpbmVyXG59KSB7XG4gIC8qKiBUaGlzIGhhcyB0byBiZSBhIGNvbXBvbmVudCBiZWNhdXNlIGl0IHdvdWxkIG5vdCBiZSBhYmxlIHRvIGNhbGwgdXNlVGhyZWUvdXNlU3RvcmUgb3RoZXJ3aXNlIHNpbmNlXG4gICAqICBpZiB0aGlzIGlzIG91ciBlbnZpcm9ubWVudCwgdGhlbiB3ZSBhcmUgbm90IGluIHIzZidzIHJlbmRlcmVyIGJ1dCBpbiByZWFjdC1kb20sIGl0IHdvdWxkIHRyaWdnZXJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxuICAgKiAgPENhbnZhcz5cbiAgICogICAge2NyZWF0ZVBvcnRhbCguLi4pfSAqL1xuICBjb25zdCB7XG4gICAgZXZlbnRzLFxuICAgIHNpemUsXG4gICAgLi4ucmVzdFxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUm9vdCA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IFtyYXljYXN0ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlJheWNhc3RlcigpKTtcbiAgY29uc3QgW3BvaW50ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlZlY3RvcjIoKSk7XG4gIGNvbnN0IGluamVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChyb290U3RhdGUsIGluamVjdFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0ge1xuICAgICAgLi4ucm9vdFN0YXRlXG4gICAgfTsgLy8gYWxsIHByZXYgc3RhdGUgcHJvcHNcblxuICAgIC8vIE9ubHkgdGhlIGZpZWxkcyBvZiBcInJvb3RTdGF0ZVwiIHRoYXQgZG8gbm90IGRpZmZlciBmcm9tIGluamVjdFN0YXRlXG4gICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgIE9iamVjdC5rZXlzKHJvb3RTdGF0ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgICAgcHJpdmF0ZUtleXMuaW5jbHVkZXMoa2V5KSB8fFxuICAgICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAvLyBVbmxlc3MgdGhlIGluamVjdCBsYXllciBwcm9wcyBpcyB1bmRlZmluZWQsIHRoZW4gd2Uga2VlcCB0aGUgcm9vdCBsYXllclxuICAgICAgcm9vdFN0YXRlW2tleV0gIT09IGluamVjdFN0YXRlW2tleV0gJiYgaW5qZWN0U3RhdGVba2V5XSkge1xuICAgICAgICBkZWxldGUgaW50ZXJzZWN0W2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChpbmplY3RTdGF0ZSAmJiBzaXplKSB7XG4gICAgICBjb25zdCBjYW1lcmEgPSBpbmplY3RTdGF0ZS5jYW1lcmE7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJyaWRlIHZpZXdwb3J0LCBpZiBwcmVzZW50XG4gICAgICB2aWV3cG9ydCA9IHJvb3RTdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBzaXplKTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcG9ydGFsIGNhbWVyYSwgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyBsYXllclxuICAgICAgaWYgKGNhbWVyYSAhPT0gcm9vdFN0YXRlLmNhbWVyYSkgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGUgaW50ZXJzZWN0IGNvbnNpc3RzIG9mIHRoZSBwcmV2aW91cyByb290IHN0YXRlXG4gICAgICAuLi5pbnRlcnNlY3QsXG4gICAgICAvLyBQb3J0YWxzIGhhdmUgdGhlaXIgb3duIHNjZW5lLCB3aGljaCBmb3JtcyB0aGUgcm9vdCwgYSByYXljYXN0ZXIgYW5kIGEgcG9pbnRlclxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIC8vIFRoZWlyIHByZXZpb3VzIHJvb3QgaXMgdGhlIGxheWVyIGJlZm9yZSBpdFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgLy8gRXZlbnRzLCBzaXplIGFuZCB2aWV3cG9ydCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgaW5qZWN0IGxheWVyXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uKGluamVjdFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBpbmplY3RTdGF0ZS5ldmVudHMpLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAuLi52aWV3cG9ydFxuICAgICAgfSxcbiAgICAgIC4uLnJlc3RcbiAgICB9O1xuICB9LFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIFtzdGF0ZV0pO1xuICBjb25zdCBbdXNlUG9ydGFsU3RvcmVdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIC8vIENyZWF0ZSBhIG1pcnJvcmVkIHN0b3JlLCBiYXNlZCBvbiB0aGUgcHJldmlvdXMgcm9vdCB3aXRoIGEgZmV3IG92ZXJyaWRlcyAuLi5cbiAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gcHJldmlvdXNSb290LmdldFN0YXRlKCk7XG4gICAgY29uc3Qgc3RvcmUgPSBjcmVhdGUoKHNldCwgZ2V0KSA9PiAoe1xuICAgICAgLi4ucHJldmlvdXNTdGF0ZSxcbiAgICAgIHNjZW5lOiBjb250YWluZXIsXG4gICAgICByYXljYXN0ZXIsXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICBwcmV2aW91c1Jvb3QsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5ldmVudHMsXG4gICAgICAgIC4uLmV2ZW50c1xuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgLi4ucHJldmlvdXNTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgLi4ucmVzdCxcbiAgICAgIC8vIFNldCBhbmQgZ2V0IHJlZmVyIHRvIHRoaXMgcm9vdC1zdGF0ZVxuICAgICAgc2V0LFxuICAgICAgZ2V0LFxuICAgICAgLy8gTGF5ZXJzIGFyZSBhbGxvd2VkIHRvIG92ZXJyaWRlIGV2ZW50c1xuICAgICAgc2V0RXZlbnRzOiBldmVudHMgPT4gc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgLi4uZXZlbnRzXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH0pKTtcbiAgICByZXR1cm4gc3RvcmU7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFN1YnNjcmliZSB0byBwcmV2aW91cyByb290LXN0YXRlIGFuZCBjb3B5IGNoYW5nZXMgb3ZlciB0byB0aGUgbWlycm9yZWQgcG9ydGFsLXN0YXRlXG4gICAgY29uc3QgdW5zdWIgPSBwcmV2aW91c1Jvb3Quc3Vic2NyaWJlKHByZXYgPT4gdXNlUG9ydGFsU3RvcmUuc2V0U3RhdGUoc3RhdGUgPT4gaW5qZWN0KHByZXYsIHN0YXRlKSkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB1bnN1YigpO1xuICAgICAgdXNlUG9ydGFsU3RvcmUuZGVzdHJveSgpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXNlUG9ydGFsU3RvcmUuc2V0U3RhdGUoaW5qZWN0U3RhdGUgPT4gaW5qZWN0KHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpLCBpbmplY3RTdGF0ZSkpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2luamVjdF0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHJlY29uY2lsZXIuY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHVzZVBvcnRhbFN0b3JlXG4gIH0sIGNoaWxkcmVuKSwgdXNlUG9ydGFsU3RvcmUsIG51bGwpKTtcbn1cbnJlY29uY2lsZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgYnVuZGxlVHlwZTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyA/IDAgOiAxLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAnQHJlYWN0LXRocmVlL2ZpYmVyJyxcbiAgdmVyc2lvbjogUmVhY3QudmVyc2lvblxufSk7XG5jb25zdCBhY3QgPSBSZWFjdC51bnN0YWJsZV9hY3Q7XG5cbmV4cG9ydCB7IHVzZVRocmVlIGFzIEEsIEJsb2NrIGFzIEIsIHVzZUZyYW1lIGFzIEMsIHVzZUdyYXBoIGFzIEQsIEVycm9yQm91bmRhcnkgYXMgRSwgdXNlTG9hZGVyIGFzIEYsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgYXMgYSwgY3JlYXRlUm9vdCBhcyBiLCBjcmVhdGVFdmVudHMgYXMgYywgdW5tb3VudENvbXBvbmVudEF0Tm9kZSBhcyBkLCBleHRlbmQgYXMgZSwgY29udGV4dCBhcyBmLCBjcmVhdGVQb3J0YWwgYXMgZywgcmVjb25jaWxlciBhcyBoLCBpc1JlZiBhcyBpLCBhcHBseVByb3BzIGFzIGosIGRpc3Bvc2UgYXMgaywgaW52YWxpZGF0ZSBhcyBsLCBhZHZhbmNlIGFzIG0sIGFkZEVmZmVjdCBhcyBuLCBhZGRBZnRlckVmZmVjdCBhcyBvLCBhZGRUYWlsIGFzIHAsIGZsdXNoR2xvYmFsRWZmZWN0cyBhcyBxLCByZW5kZXIgYXMgciwgZ2V0Um9vdFN0YXRlIGFzIHMsIHRocmVlVHlwZXMgYXMgdCwgdXNlTXV0YWJsZUNhbGxiYWNrIGFzIHUsIGFjdCBhcyB2LCBidWlsZEdyYXBoIGFzIHcsIHJvb3RzIGFzIHgsIHVzZUluc3RhbmNlSGFuZGxlIGFzIHksIHVzZVN0b3JlIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJUSFJFRSIsIlJlYWN0IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbmN1cnJlbnRSb290IiwiY3JlYXRlIiwiUmVjb25jaWxlciIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJzdXNwZW5kIiwicHJlbG9hZCIsImNsZWFyIiwidGhyZWVUeXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImNhdGFsb2d1ZSIsImV4dGVuZCIsIm9iamVjdHMiLCJhc3NpZ24iLCJjcmVhdGVSZW5kZXJlciIsIl9yb290cyIsIl9nZXRFdmVudFByaW9yaXR5IiwiY3JlYXRlSW5zdGFuY2UiLCJ0eXBlIiwiYXJncyIsImF0dGFjaCIsInByb3BzIiwicm9vdCIsIm5hbWUiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiaW5zdGFuY2UiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJFcnJvciIsInByZXBhcmUiLCJwcmltaXRpdmUiLCJ0YXJnZXQiLCJBcnJheSIsImlzQXJyYXkiLCJtZW1vaXplZFByb3BzIiwiX19yM2YiLCJCdWZmZXJHZW9tZXRyeSIsIk1hdGVyaWFsIiwiYXBwbHlQcm9wcyQxIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImNoaWxkIiwiYWRkZWQiLCJfY2hpbGQkX19yM2YiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YiLCJpc09iamVjdDNEIiwiYWRkIiwicHVzaCIsInBhcmVudCIsInVwZGF0ZUluc3RhbmNlIiwiaW52YWxpZGF0ZUluc3RhbmNlIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlQ2hpbGQiLCJfY2hpbGQkX19yM2YyIiwiX3BhcmVudEluc3RhbmNlJF9fcjNmMiIsImRpc3BhdGNoRXZlbnQiLCJyZXN0U2libGluZ3MiLCJjaGlsZHJlbiIsImZpbHRlciIsInNpYmxpbmciLCJpbmRleCIsImluZGV4T2YiLCJyZW1vdmVSZWN1cnNpdmUiLCJhcnJheSIsImRpc3Bvc2UiLCJmb3JFYWNoIiwicmVtb3ZlQ2hpbGQiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YzIiwiX2NoaWxkJF9fcjNmMyIsIl9jaGlsZCRfX3IzZjUiLCJ4IiwiZGV0YWNoIiwiX2NoaWxkJF9fcjNmNCIsInJlbW92ZSIsInJlbW92ZUludGVyYWN0aXZpdHkiLCJpc1ByaW1pdGl2ZSIsInNob3VsZERpc3Bvc2UiLCJfY2hpbGQkX19yM2Y2IiwiY2FsbGJhY2siLCJlIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwic3dpdGNoSW5zdGFuY2UiLCJuZXdQcm9wcyIsImZpYmVyIiwiX2luc3RhbmNlJF9fcjNmIiwibmV3SW5zdGFuY2UiLCJhdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCIsInJheWNhc3QiLCJldmVudENvdW50Iiwicm9vdFN0YXRlIiwiZ2V0U3RhdGUiLCJpbnRlcm5hbCIsImludGVyYWN0aW9uIiwiYWx0ZXJuYXRlIiwic3RhdGVOb2RlIiwicmVmIiwiY3VycmVudCIsImhhbmRsZVRleHRJbnN0YW5jZSIsImNvbnNvbGUiLCJ3YXJuIiwicmVjb25jaWxlciIsImFwcGVuZEluaXRpYWxDaGlsZCIsInN1cHBvcnRzTXV0YXRpb24iLCJpc1ByaW1hcnlSZW5kZXJlciIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJzdXBwb3J0c0h5ZHJhdGlvbiIsIm5vVGltZW91dCIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJjb250YWluZXIiLCJzY2VuZSIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0IiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJfaW5zdGFuY2UkX19yM2YyIiwibG9jYWxTdGF0ZSIsIkJvb2xlYW4iLCJoYW5kbGVycyIsInByZXBhcmVVcGRhdGUiLCJfdHlwZSIsIm9sZFByb3BzIiwiX2luc3RhbmNlJF9fcjNmMyIsImFyZ3NOZXciLCJjTiIsInJlc3ROZXciLCJhcmdzT2xkIiwiY08iLCJyZXN0T2xkIiwic29tZSIsInZhbHVlIiwiZGlmZiIsImRpZmZQcm9wcyIsImNoYW5nZXMiLCJsZW5ndGgiLCJjb21taXRVcGRhdGUiLCJyZWNvbnN0cnVjdCIsIl9vbGRQcm9wcyIsImNvbW1pdE1vdW50IiwiX3Byb3BzIiwiX2ludCIsIl9pbnN0YW5jZSRfX3IzZjQiLCJnZXRQdWJsaWNJbnN0YW5jZSIsInByZXBhcmVGb3JDb21taXQiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJyZXNldEFmdGVyQ29tbWl0Iiwic2hvdWxkU2V0VGV4dENvbnRlbnQiLCJjbGVhckNvbnRhaW5lciIsImhpZGVJbnN0YW5jZSIsIl9pbnN0YW5jZSRfX3IzZjUiLCJ2aXNpYmxlIiwidW5oaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkX19yM2Y2IiwiY3JlYXRlVGV4dEluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsImdldEN1cnJlbnRFdmVudFByaW9yaXR5IiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJub3ciLCJwZXJmb3JtYW5jZSIsImlzIiwiZnVuIiwiRGF0ZSIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiLCJjYW5jZWxUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiYXBwbHlQcm9wcyIsIl93aW5kb3ckZG9jdW1lbnQiLCJfd2luZG93JG5hdmlnYXRvciIsImhhc0NvbG9yU3BhY2UiLCJnZXRDb2xvck1hbmFnZW1lbnQiLCJfQ29sb3JNYW5hZ2VtZW50IiwiQ29sb3JNYW5hZ2VtZW50IiwiaXNPcnRob2dyYXBoaWNDYW1lcmEiLCJkZWYiLCJpc1JlZiIsIm9iaiIsImhhc093blByb3BlcnR5IiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsIndpbmRvdyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJmbiIsInVzZVJlZiIsIkJsb2NrIiwic2V0IiwiUHJvbWlzZSIsIkVycm9yQm91bmRhcnkiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInN0YXRlIiwiZXJyb3IiLCJjb21wb25lbnREaWRDYXRjaCIsImVyciIsInJlbmRlciIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsIkRFRkFVTFQiLCJERUZBVUxUUyIsIk1hcCIsImlzRGlmZlNldCIsIm1lbW9pemVkIiwiY2FsY3VsYXRlRHByIiwiZHByIiwiX3dpbmRvdyRkZXZpY2VQaXhlbFJhIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIk1hdGgiLCJtaW4iLCJtYXgiLCJnZXRSb290U3RhdGUiLCJfcjNmIiwiYSIsImFyciIsInN0ciIsIm51bSIsImJvbyIsInVuZCIsImVxdSIsImIiLCJhcnJheXMiLCJzdHJpY3QiLCJpc09iaiIsImlzQXJyIiwiaSIsImtleXMiLCJidWlsZEdyYXBoIiwiZGF0YSIsIm5vZGVzIiwibWF0ZXJpYWxzIiwidHJhdmVyc2UiLCJtYXRlcmlhbCIsInAiLCJwcmV2aW91c0F0dGFjaCIsInJlc29sdmUiLCJrZXkiLCJpbmNsdWRlcyIsImVudHJpZXMiLCJzcGxpdCIsImxhc3QiLCJwb3AiLCJyZWR1Y2UiLCJhY2MiLCJJTkRFWF9SRUdFWCIsInRlc3QiLCJyZXBsYWNlIiwicHJldmlvdXMiLCJrTiIsInJOIiwiY1AiLCJrUCIsInJQIiwicHJldmlvdXNLZXlzIiwidW5zaGlmdCIsInByb3AiLCJzdGFydHNXaXRoIiwiX19ERVZfXyIsInByb2Nlc3MiLCJfcm9vdCRnZXRTdGF0ZSIsInByZXZIYW5kbGVycyIsImlzRXZlbnQiLCJzUkdCRW5jb2RpbmciLCJTUkdCQ29sb3JTcGFjZSIsIkxpbmVhclNSR0JDb2xvclNwYWNlIiwiY3VycmVudEluc3RhbmNlIiwidGFyZ2V0UHJvcCIsInJldmVyc2VFbnRyaWVzIiwicmV2ZXJzZSIsImN0b3IiLCJnZXQiLCJjb3B5IiwiTGF5ZXJzIiwiZnJvbUFycmF5IiwiaXNDb2xvciIsIkNvbG9yIiwic2V0U2NhbGFyIiwibWFzayIsImxpbmVhciIsImNvbnZlcnRTUkdCVG9MaW5lYXIiLCJUZXh0dXJlIiwiZm9ybWF0IiwiUkdCQUZvcm1hdCIsIlVuc2lnbmVkQnl0ZVR5cGUiLCJ0ZXh0dXJlIiwiZ2wiLCJjb2xvclNwYWNlIiwib3V0cHV0Q29sb3JTcGFjZSIsImVuY29kaW5nIiwib3V0cHV0RW5jb2RpbmciLCJzcGxpY2UiLCJpc0NpcmN1bGFyIiwiX2luc3RhbmNlJF9fcjNmNSRyb290IiwiZnJhbWVzIiwiaW52YWxpZGF0ZSIsIm9uVXBkYXRlIiwidXBkYXRlQ2FtZXJhIiwiY2FtZXJhIiwic2l6ZSIsIm1hbnVhbCIsImxlZnQiLCJ3aWR0aCIsInJpZ2h0IiwidG9wIiwiaGVpZ2h0IiwiYm90dG9tIiwiYXNwZWN0IiwidXBkYXRlUHJvamVjdGlvbk1hdHJpeCIsInVwZGF0ZU1hdHJpeFdvcmxkIiwibWFrZUlkIiwiZXZlbnQiLCJldmVudE9iamVjdCIsInV1aWQiLCJpbnN0YW5jZUlkIiwiZ2V0RXZlbnRQcmlvcml0eSIsIl9nbG9iYWxTY29wZSRldmVudCIsImdsb2JhbFNjb3BlIiwic2VsZiIsInJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlIiwiY2FwdHVyZWRNYXAiLCJjYXB0dXJlcyIsInBvaW50ZXJJZCIsImNhcHR1cmVEYXRhIiwiZGVsZXRlIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwic3RvcmUiLCJvIiwiaW5pdGlhbEhpdHMiLCJob3ZlcmVkIiwiY3JlYXRlRXZlbnRzIiwiY2FsY3VsYXRlRGlzdGFuY2UiLCJkeCIsIm9mZnNldFgiLCJpbml0aWFsQ2xpY2siLCJkeSIsIm9mZnNldFkiLCJyb3VuZCIsInNxcnQiLCJmaWx0ZXJQb2ludGVyRXZlbnRzIiwiaW50ZXJzZWN0IiwiZHVwbGljYXRlcyIsIlNldCIsImludGVyc2VjdGlvbnMiLCJldmVudHNPYmplY3RzIiwicmF5Y2FzdGVyIiwicHJldmlvdXNSb290IiwiZXZlbnRzIiwiY29tcHV0ZSIsImhhbmRsZVJheWNhc3QiLCJlbmFibGVkIiwiX3N0YXRlJHByZXZpb3VzUm9vdCIsImludGVyc2VjdE9iamVjdCIsImhpdHMiLCJmbGF0TWFwIiwic29ydCIsImFTdGF0ZSIsImJTdGF0ZSIsImRpc3RhbmNlIiwicHJpb3JpdHkiLCJpdGVtIiwiaWQiLCJoYXMiLCJoaXQiLCJfcjNmMiIsInZhbHVlcyIsImludGVyc2VjdGlvbiIsImhhbmRsZUludGVyc2VjdHMiLCJkZWx0YSIsInN0b3BwZWQiLCJwb2ludGVyIiwidW5wcm9qZWN0ZWRQb2ludCIsIlZlY3RvcjMiLCJ5IiwidW5wcm9qZWN0IiwiaGFzUG9pbnRlckNhcHR1cmUiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAiLCJfaW50ZXJuYWwkY2FwdHVyZWRNYXAyIiwic2V0UG9pbnRlckNhcHR1cmUiLCJleHRyYWN0RXZlbnRQcm9wcyIsInByb3BlcnR5IiwicmF5Y2FzdEV2ZW50IiwicmF5Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FwdHVyZXNGb3JQb2ludGVyIiwiZnJvbSIsImZpbmQiLCJoaWdoZXIiLCJjYW5jZWxQb2ludGVyIiwiY3VycmVudFRhcmdldCIsIm5hdGl2ZUV2ZW50IiwiaG92ZXJlZE9iaiIsIm9uUG9pbnRlck91dCIsIm9uUG9pbnRlckxlYXZlIiwicG9pbnRlck1pc3NlZCIsIm9uUG9pbnRlck1pc3NlZCIsImhhbmRsZVBvaW50ZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVFdmVudCIsImxhc3RFdmVudCIsImlzUG9pbnRlck1vdmUiLCJpc0NsaWNrRXZlbnQiLCJtYXAiLCJvbkludGVyc2VjdCIsIm9uUG9pbnRlck92ZXIiLCJvblBvaW50ZXJFbnRlciIsImhvdmVyZWRJdGVtIiwib25Qb2ludGVyTW92ZSIsImhhbmRsZXIiLCJwcml2YXRlS2V5cyIsImlzUmVuZGVyZXIiLCJjb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZVN0b3JlIiwiYWR2YW5jZSIsInBvc2l0aW9uIiwiZGVmYXVsdFRhcmdldCIsInRlbXBUYXJnZXQiLCJnZXRDdXJyZW50Vmlld3BvcnQiLCJnZXRXb3JsZFBvc2l0aW9uIiwiZGlzdGFuY2VUbyIsInpvb20iLCJmYWN0b3IiLCJmb3YiLCJQSSIsImgiLCJ0YW4iLCJ3IiwicGVyZm9ybWFuY2VUaW1lb3V0Iiwic2V0UGVyZm9ybWFuY2VDdXJyZW50IiwiVmVjdG9yMiIsImNvbm5lY3RlZCIsInhyIiwidGltZXN0YW1wIiwicnVuR2xvYmFsRWZmZWN0cyIsImxlZ2FjeSIsImZsYXQiLCJjb250cm9scyIsImNsb2NrIiwiQ2xvY2siLCJtb3VzZSIsImZyYW1lbG9vcCIsImRlYm91bmNlIiwicmVncmVzcyIsInVwZGF0ZVN0eWxlIiwidmlld3BvcnQiLCJpbml0aWFsRHByIiwic2V0RXZlbnRzIiwic2V0U2l6ZSIsInNldERwciIsInJlc29sdmVkIiwic2V0RnJhbWVsb29wIiwic3RvcCIsImVsYXBzZWRUaW1lIiwic3RhcnQiLCJhY3RpdmUiLCJjcmVhdGVSZWYiLCJzdWJzY3JpYmVycyIsInN1YnNjcmliZSIsInMiLCJvbGRTaXplIiwib2xkRHByIiwib2xkQ2FtZXJhIiwiX3NpemUkdXBkYXRlU3R5bGUiLCJzZXRQaXhlbFJhdGlvIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJkb21FbGVtZW50IiwiY3JlYXRlU3VicyIsInN1YnMiLCJzdWIiLCJnbG9iYWxFZmZlY3RzIiwiZ2xvYmFsQWZ0ZXJFZmZlY3RzIiwiZ2xvYmFsVGFpbEVmZmVjdHMiLCJhZGRFZmZlY3QiLCJhZGRBZnRlckVmZmVjdCIsImFkZFRhaWwiLCJydW4iLCJlZmZlY3RzIiwiZmx1c2hHbG9iYWxFZmZlY3RzIiwic3Vic2NyaXB0aW9uIiwicmVuZGVyJDEiLCJmcmFtZSIsImdldERlbHRhIiwib2xkVGltZSIsImNyZWF0ZUxvb3AiLCJyb290cyIsInJ1bm5pbmciLCJyZXBlYXQiLCJsb29wIiwiX3N0YXRlJGdsJHhyIiwiaXNQcmVzZW50aW5nIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJfc3RhdGUkZ2wkeHIyIiwidXNlSW5zdGFuY2VIYW5kbGUiLCJ1c2VTdG9yZSIsInVzZUNvbnRleHQiLCJ1c2VUaHJlZSIsInNlbGVjdG9yIiwiZXF1YWxpdHlGbiIsInVzZUZyYW1lIiwicmVuZGVyUHJpb3JpdHkiLCJ1c2VHcmFwaCIsInVzZU1lbW8iLCJtZW1vaXplZExvYWRlcnMiLCJXZWFrTWFwIiwibG9hZGluZ0ZuIiwiZXh0ZW5zaW9ucyIsIm9uUHJvZ3Jlc3MiLCJQcm90byIsImlucHV0IiwibG9hZGVyIiwiYWxsIiwicmVzIiwicmVqZWN0IiwibG9hZCIsIm1lc3NhZ2UiLCJmaW5hbGx5IiwidXNlTG9hZGVyIiwicmVzdWx0cyIsImVxdWFsIiwic2hhbGxvd0xvb3NlIiwiY3JlYXRlUmVuZGVyZXJJbnN0YW5jZSIsImNhbnZhcyIsImN1c3RvbVJlbmRlcmVyIiwiV2ViR0xSZW5kZXJlciIsInBvd2VyUHJlZmVyZW5jZSIsImFudGlhbGlhcyIsImFscGhhIiwiY29tcHV0ZUluaXRpYWxTaXplIiwiZGVmYXVsdFNpemUiLCJkZWZhdWx0U3R5bGUiLCJwYXJlbnRFbGVtZW50IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiT2Zmc2NyZWVuQ2FudmFzIiwiY3JlYXRlUm9vdCIsInByZXZSb290IiwicHJldkZpYmVyIiwicHJldlN0b3JlIiwibG9nUmVjb3ZlcmFibGVFcnJvciIsInJlcG9ydEVycm9yIiwiY3JlYXRlQ29udGFpbmVyIiwib25DcmVhdGVkIiwiY29uZmlndXJlZCIsImxhc3RDYW1lcmEiLCJjb25maWd1cmUiLCJnbENvbmZpZyIsInByb3BzU2l6ZSIsInNjZW5lT3B0aW9ucyIsIm9uQ3JlYXRlZENhbGxiYWNrIiwic2hhZG93cyIsIm9ydGhvZ3JhcGhpYyIsInJheWNhc3RPcHRpb25zIiwiY2FtZXJhT3B0aW9ucyIsIlJheWNhc3RlciIsInBhcmFtcyIsIm9wdGlvbnMiLCJpc0NhbWVyYSIsIkNhbWVyYSIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIlBlcnNwZWN0aXZlQ2FtZXJhIiwieiIsInJvdGF0aW9uIiwibG9va0F0IiwiU2NlbmUiLCJfZ2wkeHIiLCJoYW5kbGVYUkZyYW1lIiwiaGFuZGxlU2Vzc2lvbkNoYW5nZSIsInNldEFuaW1hdGlvbkxvb3AiLCJjb25uZWN0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2hhZG93TWFwIiwib2xkRW5hYmxlZCIsIm9sZFR5cGUiLCJQQ0ZTb2Z0U2hhZG93TWFwIiwiX3R5cGVzJHNoYWRvd3MiLCJ0eXBlcyIsImJhc2ljIiwiQmFzaWNTaGFkb3dNYXAiLCJwZXJjZW50YWdlIiwiUENGU2hhZG93TWFwIiwic29mdCIsInZhcmlhbmNlIiwiVlNNU2hhZG93TWFwIiwibmVlZHNVcGRhdGUiLCJsZWdhY3lNb2RlIiwiTGluZWFyRW5jb2RpbmciLCJ0b25lTWFwcGluZyIsIk5vVG9uZU1hcHBpbmciLCJBQ0VTRmlsbWljVG9uZU1hcHBpbmciLCJ1cGRhdGVDb250YWluZXIiLCJQcm92aWRlciIsInJvb3RFbGVtZW50IiwidW5tb3VudCIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJjb25maWciLCJfc3RhdGUkZ2wiLCJfc3RhdGUkZ2wkcmVuZGVyTGlzdHMiLCJfc3RhdGUkZ2wyIiwiX3N0YXRlJGdsMyIsInJlbmRlckxpc3RzIiwiZm9yY2VDb250ZXh0TG9zcyIsImNyZWF0ZVBvcnRhbCIsIlBvcnRhbCIsInJlc3QiLCJ1c2VTdGF0ZSIsImluamVjdCIsInVzZUNhbGxiYWNrIiwiaW5qZWN0U3RhdGUiLCJ1c2VQb3J0YWxTdG9yZSIsInByZXZpb3VzU3RhdGUiLCJ1bnN1YiIsInByZXYiLCJzZXRTdGF0ZSIsImRlc3Ryb3kiLCJGcmFnbWVudCIsImluamVjdEludG9EZXZUb29scyIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwidmVyc2lvbiIsImFjdCIsInVuc3RhYmxlX2FjdCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsImMiLCJkIiwiZiIsImciLCJqIiwiayIsImwiLCJtIiwibiIsInEiLCJyIiwidCIsInUiLCJ2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-710fb441.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   act: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addEffect: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   addTail: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   advance: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   applyProps: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   buildGraph: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   context: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createEvents: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createRoot: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   events: () => (/* binding */ createPointerEvents),\n/* harmony export */   extend: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRootState: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   reconciler: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   render: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useGraph: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useLoader: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   useStore: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   useThree: () => (/* reexport safe */ _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.A)\n/* harmony export */ });\n/* harmony import */ var _index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-710fb441.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-710fb441.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/web.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = (0,_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = createPointerEvents, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, scene, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>(0,_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    (0,_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                scene,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(Bridge, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                set: setError\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Suspense, {\n                fallback: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                    set: setBlock\n                })\n            }, children))));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_index_710fb441_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        }\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"canvas\", {\n        ref: canvasRef,\n        style: {\n            display: \"block\"\n        }\n    }, fallback)));\n});\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CanvasImpl, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({}, props, {\n        ref: ref\n    })));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNE47QUFDeVI7QUFDM2I7QUFDM0I7QUFDQTtBQUNZO0FBQ2dCO0FBQ3ZCO0FBQ25CO0FBQ1M7QUFDUDtBQUNJO0FBRXZCLE1BQU1zRSxhQUFhO0lBQ2pCQyxTQUFTO1FBQUM7UUFBUztLQUFNO0lBQ3pCQyxlQUFlO1FBQUM7UUFBZTtLQUFNO0lBQ3JDQyxlQUFlO1FBQUM7UUFBWTtLQUFNO0lBQ2xDQyxTQUFTO1FBQUM7UUFBUztLQUFLO0lBQ3hCQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxhQUFhO1FBQUM7UUFBYTtLQUFLO0lBQ2hDQyxnQkFBZ0I7UUFBQztRQUFnQjtLQUFLO0lBQ3RDQyxlQUFlO1FBQUM7UUFBZTtLQUFLO0lBQ3BDQyxpQkFBaUI7UUFBQztRQUFpQjtLQUFLO0lBQ3hDQyxzQkFBc0I7UUFBQztRQUFzQjtLQUFLO0FBQ3BEO0FBRUEsc0NBQXNDLEdBQ3RDLFNBQVNDLG9CQUFvQkMsS0FBSztJQUNoQyxNQUFNLEVBQ0pDLGFBQWEsRUFDZCxHQUFHbEYseURBQVlBLENBQUNpRjtJQUNqQixPQUFPO1FBQ0xFLFVBQVU7UUFDVkMsU0FBUztRQUNUQyxTQUFRQyxLQUFLLEVBQUVDLEtBQUssRUFBRUMsUUFBUTtZQUM1Qix1REFBdUQ7WUFDdkQsNEZBQTRGO1lBQzVGRCxNQUFNRSxPQUFPLENBQUNDLEdBQUcsQ0FBQ0osTUFBTUssT0FBTyxHQUFHSixNQUFNSyxJQUFJLENBQUNDLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBRVAsQ0FBQUEsTUFBTVEsT0FBTyxHQUFHUCxNQUFNSyxJQUFJLENBQUNHLE1BQU0sSUFBSSxJQUFJO1lBQ3ZHUixNQUFNUyxTQUFTLENBQUNDLGFBQWEsQ0FBQ1YsTUFBTUUsT0FBTyxFQUFF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QUFPO1FBQ2hDLElBQUlzRCxRQUFRLE9BQU8sSUFBTXZKLHlEQUFzQkEsQ0FBQ3VKO0lBQ2xELEdBQUcsRUFBRTtJQUVMLCtFQUErRTtJQUMvRSxzRUFBc0U7SUFDdEUsTUFBTU8sZ0JBQWdCdkMsY0FBYyxTQUFTO0lBQzdDLE9BQU8sV0FBVyxHQUFFdkUsZ0RBQW1CLENBQUMsT0FBT0QsOEVBQVFBLENBQUM7UUFDdERnSCxLQUFLakI7UUFDTHpCLE9BQU87WUFDTDJDLFVBQVU7WUFDVm5GLE9BQU87WUFDUEUsUUFBUTtZQUNSa0YsVUFBVTtZQUNWSDtZQUNBLEdBQUd6QyxLQUFLO1FBQ1Y7SUFDRixHQUFHZSxRQUFRLFdBQVcsR0FBRXBGLGdEQUFtQixDQUFDLE9BQU87UUFDakQrRyxLQUFLdkI7UUFDTG5CLE9BQU87WUFDTHhDLE9BQU87WUFDUEUsUUFBUTtRQUNWO0lBQ0YsR0FBRyxXQUFXLEdBQUUvQixnREFBbUIsQ0FBQyxVQUFVO1FBQzVDK0csS0FBS25CO1FBQ0x2QixPQUFPO1lBQ0w2QyxTQUFTO1FBQ1g7SUFDRixHQUFHL0M7QUFDTDtBQUVBOzs7Q0FHQyxHQUNELE1BQU1GLFNBQVMsV0FBVyxHQUFFakUsNkNBQWdCLENBQUMsU0FBU21ILGNBQWMvQixLQUFLLEVBQUUyQixHQUFHO0lBQzVFLE9BQU8sV0FBVyxHQUFFL0csZ0RBQW1CLENBQUNHLG1EQUFhQSxFQUFFLE1BQU0sV0FBVyxHQUFFSCxnREFBbUIsQ0FBQytELFlBQVloRSw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdxRixPQUFPO1FBQzVIMkIsS0FBS0E7SUFDUDtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2UtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L3JlYWN0LXRocmVlLWZpYmVyLmVzbS5qcz83OWNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY3JlYXRlRXZlbnRzLCBlIGFzIGV4dGVuZCwgdSBhcyB1c2VNdXRhYmxlQ2FsbGJhY2ssIGEgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgYiBhcyBjcmVhdGVSb290LCBpIGFzIGlzUmVmLCBFIGFzIEVycm9yQm91bmRhcnksIEIgYXMgQmxvY2ssIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB9IGZyb20gJy4vaW5kZXgtNzEwZmI0NDEuZXNtLmpzJztcbmV4cG9ydCB7IHQgYXMgUmVhY3RUaHJlZUZpYmVyLCB4IGFzIF9yb290cywgdiBhcyBhY3QsIG8gYXMgYWRkQWZ0ZXJFZmZlY3QsIG4gYXMgYWRkRWZmZWN0LCBwIGFzIGFkZFRhaWwsIG0gYXMgYWR2YW5jZSwgaiBhcyBhcHBseVByb3BzLCB3IGFzIGJ1aWxkR3JhcGgsIGYgYXMgY29udGV4dCwgYyBhcyBjcmVhdGVFdmVudHMsIGcgYXMgY3JlYXRlUG9ydGFsLCBiIGFzIGNyZWF0ZVJvb3QsIGsgYXMgZGlzcG9zZSwgZSBhcyBleHRlbmQsIHEgYXMgZmx1c2hHbG9iYWxFZmZlY3RzLCBzIGFzIGdldFJvb3RTdGF0ZSwgbCBhcyBpbnZhbGlkYXRlLCBoIGFzIHJlY29uY2lsZXIsIHIgYXMgcmVuZGVyLCBkIGFzIHVubW91bnRDb21wb25lbnRBdE5vZGUsIEMgYXMgdXNlRnJhbWUsIEQgYXMgdXNlR3JhcGgsIHkgYXMgdXNlSW5zdGFuY2VIYW5kbGUsIEYgYXMgdXNlTG9hZGVyLCB6IGFzIHVzZVN0b3JlLCBBIGFzIHVzZVRocmVlIH0gZnJvbSAnLi9pbmRleC03MTBmYjQ0MS5lc20uanMnO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHVzZU1lYXN1cmUgZnJvbSAncmVhY3QtdXNlLW1lYXN1cmUnO1xuaW1wb3J0IHsgRmliZXJQcm92aWRlciwgdXNlQ29udGV4dEJyaWRnZSB9IGZyb20gJ2l0cy1maW5lJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMnO1xuaW1wb3J0ICd6dXN0YW5kJztcbmltcG9ydCAncmVhY3QtcmVjb25jaWxlcic7XG5pbXBvcnQgJ3NjaGVkdWxlcic7XG5pbXBvcnQgJ3N1c3BlbmQtcmVhY3QnO1xuXG5jb25zdCBET01fRVZFTlRTID0ge1xuICBvbkNsaWNrOiBbJ2NsaWNrJywgZmFsc2VdLFxuICBvbkNvbnRleHRNZW51OiBbJ2NvbnRleHRtZW51JywgZmFsc2VdLFxuICBvbkRvdWJsZUNsaWNrOiBbJ2RibGNsaWNrJywgZmFsc2VdLFxuICBvbldoZWVsOiBbJ3doZWVsJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckRvd246IFsncG9pbnRlcmRvd24nLCB0cnVlXSxcbiAgb25Qb2ludGVyVXA6IFsncG9pbnRlcnVwJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckxlYXZlOiBbJ3BvaW50ZXJsZWF2ZScsIHRydWVdLFxuICBvblBvaW50ZXJNb3ZlOiBbJ3BvaW50ZXJtb3ZlJywgdHJ1ZV0sXG4gIG9uUG9pbnRlckNhbmNlbDogWydwb2ludGVyY2FuY2VsJywgdHJ1ZV0sXG4gIG9uTG9zdFBvaW50ZXJDYXB0dXJlOiBbJ2xvc3Rwb2ludGVyY2FwdHVyZScsIHRydWVdXG59O1xuXG4vKiogRGVmYXVsdCBSM0YgZXZlbnQgbWFuYWdlciBmb3Igd2ViICovXG5mdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnRzKHN0b3JlKSB7XG4gIGNvbnN0IHtcbiAgICBoYW5kbGVQb2ludGVyXG4gIH0gPSBjcmVhdGVFdmVudHMoc3RvcmUpO1xuICByZXR1cm4ge1xuICAgIHByaW9yaXR5OiAxLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgY29tcHV0ZShldmVudCwgc3RhdGUsIHByZXZpb3VzKSB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvNzgyXG4gICAgICAvLyBFdmVudHMgdHJpZ2dlciBvdXRzaWRlIG9mIGNhbnZhcyB3aGVuIG1vdmVkLCB1c2Ugb2Zmc2V0WC9ZIGJ5IGRlZmF1bHQgYW5kIGFsbG93IG92ZXJyaWRlc1xuICAgICAgc3RhdGUucG9pbnRlci5zZXQoZXZlbnQub2Zmc2V0WCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLShldmVudC5vZmZzZXRZIC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgc3RhdGUucmF5Y2FzdGVyLnNldEZyb21DYW1lcmEoc3RhdGUucG9pbnRlciwgc3RhdGUuY2FtZXJhKTtcbiAgICB9LFxuICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkLFxuICAgIGhhbmRsZXJzOiBPYmplY3Qua2V5cyhET01fRVZFTlRTKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoe1xuICAgICAgLi4uYWNjLFxuICAgICAgW2tleV06IGhhbmRsZVBvaW50ZXIoa2V5KVxuICAgIH0pLCB7fSksXG4gICAgdXBkYXRlOiAoKSA9PiB7XG4gICAgICB2YXIgX2ludGVybmFsJGxhc3RFdmVudDtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXZlbnRzLFxuICAgICAgICBpbnRlcm5hbFxuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoKF9pbnRlcm5hbCRsYXN0RXZlbnQgPSBpbnRlcm5hbC5sYXN0RXZlbnQpICE9IG51bGwgJiYgX2ludGVybmFsJGxhc3RFdmVudC5jdXJyZW50ICYmIGV2ZW50cy5oYW5kbGVycykgZXZlbnRzLmhhbmRsZXJzLm9uUG9pbnRlck1vdmUoaW50ZXJuYWwubGFzdEV2ZW50LmN1cnJlbnQpO1xuICAgIH0sXG4gICAgY29ubmVjdDogdGFyZ2V0ID0+IHtcbiAgICAgIHZhciBfZXZlbnRzJGhhbmRsZXJzO1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBldmVudHMuZGlzY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnRzLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5ldmVudHMsXG4gICAgICAgICAgY29ubmVjdGVkOiB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgT2JqZWN0LmVudHJpZXMoKF9ldmVudHMkaGFuZGxlcnMgPSBldmVudHMuaGFuZGxlcnMpICE9IG51bGwgPyBfZXZlbnRzJGhhbmRsZXJzIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgY29uc3QgW2V2ZW50TmFtZSwgcGFzc2l2ZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50LCB7XG4gICAgICAgICAgcGFzc2l2ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzZXQsXG4gICAgICAgIGV2ZW50c1xuICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICBpZiAoZXZlbnRzLmNvbm5lY3RlZCkge1xuICAgICAgICB2YXIgX2V2ZW50cyRoYW5kbGVyczI7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKChfZXZlbnRzJGhhbmRsZXJzMiA9IGV2ZW50cy5oYW5kbGVycykgIT0gbnVsbCA/IF9ldmVudHMkaGFuZGxlcnMyIDogW10pLmZvckVhY2goKFtuYW1lLCBldmVudF0pID0+IHtcbiAgICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50cy5jb25uZWN0ZWQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgW2V2ZW50TmFtZV0gPSBET01fRVZFTlRTW25hbWVdO1xuICAgICAgICAgICAgZXZlbnRzLmNvbm5lY3RlZC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgICAgY29ubmVjdGVkOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmNvbnN0IENhbnZhc0ltcGwgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXMoe1xuICBjaGlsZHJlbixcbiAgZmFsbGJhY2ssXG4gIHJlc2l6ZSxcbiAgc3R5bGUsXG4gIGdsLFxuICBldmVudHMgPSBjcmVhdGVQb2ludGVyRXZlbnRzLFxuICBldmVudFNvdXJjZSxcbiAgZXZlbnRQcmVmaXgsXG4gIHNoYWRvd3MsXG4gIGxpbmVhcixcbiAgZmxhdCxcbiAgbGVnYWN5LFxuICBvcnRob2dyYXBoaWMsXG4gIGZyYW1lbG9vcCxcbiAgZHByLFxuICBwZXJmb3JtYW5jZSxcbiAgcmF5Y2FzdGVyLFxuICBjYW1lcmEsXG4gIHNjZW5lLFxuICBvblBvaW50ZXJNaXNzZWQsXG4gIG9uQ3JlYXRlZCxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikge1xuICAvLyBDcmVhdGUgYSBrbm93biBjYXRhbG9ndWUgb2YgVGhyZWVqcy1uYXRpdmUgZWxlbWVudHNcbiAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIGVudGlyZSBUSFJFRSBuYW1lc3BhY2UgYnkgZGVmYXVsdCwgdXNlcnMgY2FuIGV4dGVuZFxuICAvLyB0aGVpciBvd24gZWxlbWVudHMgYnkgdXNpbmcgdGhlIGNyZWF0ZVJvb3QgQVBJIGluc3RlYWRcbiAgUmVhY3QudXNlTWVtbygoKSA9PiBleHRlbmQoVEhSRUUpLCBbXSk7XG4gIGNvbnN0IEJyaWRnZSA9IHVzZUNvbnRleHRCcmlkZ2UoKTtcbiAgY29uc3QgW2NvbnRhaW5lclJlZiwgY29udGFpbmVyUmVjdF0gPSB1c2VNZWFzdXJlKHtcbiAgICBzY3JvbGw6IHRydWUsXG4gICAgZGVib3VuY2U6IHtcbiAgICAgIHNjcm9sbDogNTAsXG4gICAgICByZXNpemU6IDBcbiAgICB9LFxuICAgIC4uLnJlc2l6ZVxuICB9KTtcbiAgY29uc3QgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkaXZSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiBjYW52YXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNaXNzZWQgPSB1c2VNdXRhYmxlQ2FsbGJhY2sob25Qb2ludGVyTWlzc2VkKTtcbiAgY29uc3QgW2Jsb2NrLCBzZXRCbG9ja10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFN1c3BlbmQgdGhpcyBjb21wb25lbnQgaWYgYmxvY2sgaXMgYSBwcm9taXNlICgybmQgcnVuKVxuICBpZiAoYmxvY2spIHRocm93IGJsb2NrO1xuICAvLyBUaHJvdyBleGNlcHRpb24gb3V0d2FyZHMgaWYgYW55dGhpbmcgd2l0aGluIGNhbnZhcyB0aHJvd3NcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgcm9vdCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNvbnRhaW5lclJlY3Qud2lkdGggPiAwICYmIGNvbnRhaW5lclJlY3QuaGVpZ2h0ID4gMCAmJiBjYW52YXMpIHtcbiAgICAgIGlmICghcm9vdC5jdXJyZW50KSByb290LmN1cnJlbnQgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gICAgICByb290LmN1cnJlbnQuY29uZmlndXJlKHtcbiAgICAgICAgZ2wsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgc2hhZG93cyxcbiAgICAgICAgbGluZWFyLFxuICAgICAgICBmbGF0LFxuICAgICAgICBsZWdhY3ksXG4gICAgICAgIG9ydGhvZ3JhcGhpYyxcbiAgICAgICAgZnJhbWVsb29wLFxuICAgICAgICBkcHIsXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgIGNhbWVyYSxcbiAgICAgICAgc2NlbmUsXG4gICAgICAgIHNpemU6IGNvbnRhaW5lclJlY3QsXG4gICAgICAgIC8vIFBhc3MgbXV0YWJsZSByZWZlcmVuY2UgdG8gb25Qb2ludGVyTWlzc2VkIHNvIGl0J3MgZnJlZSB0byB1cGRhdGVcbiAgICAgICAgb25Qb2ludGVyTWlzc2VkOiAoLi4uYXJncykgPT4gaGFuZGxlUG9pbnRlck1pc3NlZC5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQoLi4uYXJncyksXG4gICAgICAgIG9uQ3JlYXRlZDogc3RhdGUgPT4ge1xuICAgICAgICAgIC8vIENvbm5lY3QgdG8gZXZlbnQgc291cmNlXG4gICAgICAgICAgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KGV2ZW50U291cmNlID8gaXNSZWYoZXZlbnRTb3VyY2UpID8gZXZlbnRTb3VyY2UuY3VycmVudCA6IGV2ZW50U291cmNlIDogZGl2UmVmLmN1cnJlbnQpO1xuICAgICAgICAgIC8vIFNldCB1cCBjb21wdXRlIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKGV2ZW50UHJlZml4KSB7XG4gICAgICAgICAgICBzdGF0ZS5zZXRFdmVudHMoe1xuICAgICAgICAgICAgICBjb21wdXRlOiAoZXZlbnQsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGV2ZW50W2V2ZW50UHJlZml4ICsgJ1gnXTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWSddO1xuICAgICAgICAgICAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KHggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oeSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yYXljYXN0ZXIuc2V0RnJvbUNhbWVyYShzdGF0ZS5wb2ludGVyLCBzdGF0ZS5jYW1lcmEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ2FsbCBvbkNyZWF0ZWQgY2FsbGJhY2tcbiAgICAgICAgICBvbkNyZWF0ZWQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ3JlYXRlZChzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcm9vdC5jdXJyZW50LnJlbmRlciggLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQnJpZGdlLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIHNldDogc2V0RXJyb3JcbiAgICAgIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LlN1c3BlbnNlLCB7XG4gICAgICAgIGZhbGxiYWNrOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCbG9jaywge1xuICAgICAgICAgIHNldDogc2V0QmxvY2tcbiAgICAgICAgfSlcbiAgICAgIH0sIGNoaWxkcmVuKSkpKTtcbiAgICB9XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50O1xuICAgIGlmIChjYW52YXMpIHJldHVybiAoKSA9PiB1bm1vdW50Q29tcG9uZW50QXROb2RlKGNhbnZhcyk7XG4gIH0sIFtdKTtcblxuICAvLyBXaGVuIHRoZSBldmVudCBzb3VyY2UgaXMgbm90IHRoaXMgZGl2LCB3ZSBuZWVkIHRvIHNldCBwb2ludGVyLWV2ZW50cyB0byBub25lXG4gIC8vIE9yIGVsc2UgdGhlIGNhbnZhcyB3aWxsIGJsb2NrIGV2ZW50cyBmcm9tIHJlYWNoaW5nIHRoZSBldmVudCBzb3VyY2VcbiAgY29uc3QgcG9pbnRlckV2ZW50cyA9IGV2ZW50U291cmNlID8gJ25vbmUnIDogJ2F1dG8nO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogZGl2UmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgIHBvaW50ZXJFdmVudHMsXG4gICAgICAuLi5zdHlsZVxuICAgIH1cbiAgfSwgcHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcmVmOiBjb250YWluZXJSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwge1xuICAgIHJlZjogY2FudmFzUmVmLFxuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiAnYmxvY2snXG4gICAgfVxuICB9LCBmYWxsYmFjaykpKTtcbn0pO1xuXG4vKipcbiAqIEEgRE9NIGNhbnZhcyB3aGljaCBhY2NlcHRzIHRocmVlanMgZWxlbWVudHMgYXMgY2hpbGRyZW4uXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9jYW52YXNcbiAqL1xuY29uc3QgQ2FudmFzID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FudmFzV3JhcHBlcihwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChGaWJlclByb3ZpZGVyLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDYW52YXNJbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSkpO1xufSk7XG5cbmV4cG9ydCB7IENhbnZhcywgY3JlYXRlUG9pbnRlckV2ZW50cyBhcyBldmVudHMgfTtcbiJdLCJuYW1lcyI6WyJjIiwiY3JlYXRlRXZlbnRzIiwiZSIsImV4dGVuZCIsInUiLCJ1c2VNdXRhYmxlQ2FsbGJhY2siLCJhIiwidXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCIsImIiLCJjcmVhdGVSb290IiwiaSIsImlzUmVmIiwiRSIsIkVycm9yQm91bmRhcnkiLCJCIiwiQmxvY2siLCJkIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInQiLCJSZWFjdFRocmVlRmliZXIiLCJ4IiwiX3Jvb3RzIiwidiIsImFjdCIsIm8iLCJhZGRBZnRlckVmZmVjdCIsIm4iLCJhZGRFZmZlY3QiLCJwIiwiYWRkVGFpbCIsIm0iLCJhZHZhbmNlIiwiaiIsImFwcGx5UHJvcHMiLCJ3IiwiYnVpbGRHcmFwaCIsImYiLCJjb250ZXh0IiwiZyIsImNyZWF0ZVBvcnRhbCIsImsiLCJkaXNwb3NlIiwicSIsImZsdXNoR2xvYmFsRWZmZWN0cyIsInMiLCJnZXRSb290U3RhdGUiLCJsIiwiaW52YWxpZGF0ZSIsImgiLCJyZWNvbmNpbGVyIiwiciIsInJlbmRlciIsIkMiLCJ1c2VGcmFtZSIsIkQiLCJ1c2VHcmFwaCIsInkiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsIkYiLCJ1c2VMb2FkZXIiLCJ6IiwidXNlU3RvcmUiLCJBIiwidXNlVGhyZWUiLCJfZXh0ZW5kcyIsIlJlYWN0IiwiVEhSRUUiLCJ1c2VNZWFzdXJlIiwiRmliZXJQcm92aWRlciIsInVzZUNvbnRleHRCcmlkZ2UiLCJET01fRVZFTlRTIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbkRvdWJsZUNsaWNrIiwib25XaGVlbCIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlckxlYXZlIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlckNhbmNlbCIsIm9uTG9zdFBvaW50ZXJDYXB0dXJlIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsInN0b3JlIiwiaGFuZGxlUG9pbnRlciIsInByaW9yaXR5IiwiZW5hYmxlZCIsImNvbXB1dGUiLCJldmVudCIsInN0YXRlIiwicHJldmlvdXMiLCJwb2ludGVyIiwic2V0Iiwib2Zmc2V0WCIsInNpemUiLCJ3aWR0aCIsIm9mZnNldFkiLCJoZWlnaHQiLCJyYXljYXN0ZXIiLCJzZXRGcm9tQ2FtZXJhIiwiY2FtZXJhIiwiY29ubmVjdGVkIiwidW5kZWZpbmVkIiwiaGFuZGxlcnMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwidXBkYXRlIiwiX2ludGVybmFsJGxhc3RFdmVudCIsImV2ZW50cyIsImludGVybmFsIiwiZ2V0U3RhdGUiLCJsYXN0RXZlbnQiLCJjdXJyZW50IiwiY29ubmVjdCIsInRhcmdldCIsIl9ldmVudHMkaGFuZGxlcnMiLCJkaXNjb25uZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJuYW1lIiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfZXZlbnRzJGhhbmRsZXJzMiIsIkhUTUxFbGVtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkNhbnZhc0ltcGwiLCJmb3J3YXJkUmVmIiwiQ2FudmFzIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsInJlc2l6ZSIsInN0eWxlIiwiZ2wiLCJldmVudFNvdXJjZSIsImV2ZW50UHJlZml4Iiwic2hhZG93cyIsImxpbmVhciIsImZsYXQiLCJsZWdhY3kiLCJvcnRob2dyYXBoaWMiLCJmcmFtZWxvb3AiLCJkcHIiLCJwZXJmb3JtYW5jZSIsInNjZW5lIiwib25Qb2ludGVyTWlzc2VkIiwib25DcmVhdGVkIiwicHJvcHMiLCJmb3J3YXJkZWRSZWYiLCJ1c2VNZW1vIiwiQnJpZGdlIiwiY29udGFpbmVyUmVmIiwiY29udGFpbmVyUmVjdCIsInNjcm9sbCIsImRlYm91bmNlIiwiY2FudmFzUmVmIiwidXNlUmVmIiwiZGl2UmVmIiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsImhhbmRsZVBvaW50ZXJNaXNzZWQiLCJibG9jayIsInNldEJsb2NrIiwidXNlU3RhdGUiLCJlcnJvciIsInNldEVycm9yIiwicm9vdCIsImNhbnZhcyIsImNvbmZpZ3VyZSIsImFyZ3MiLCJzZXRFdmVudHMiLCJjcmVhdGVFbGVtZW50IiwiU3VzcGVuc2UiLCJ1c2VFZmZlY3QiLCJwb2ludGVyRXZlbnRzIiwicmVmIiwicG9zaXRpb24iLCJvdmVyZmxvdyIsImRpc3BsYXkiLCJDYW52YXNXcmFwcGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        function push(heap, node) {\n            var index = heap.length;\n            heap.push(node);\n            siftUp(heap, node, index);\n        }\n        function peek(heap) {\n            return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n            if (heap.length === 0) {\n                return null;\n            }\n            var first = heap[0];\n            var last = heap.pop();\n            if (last !== first) {\n                heap[0] = last;\n                siftDown(heap, last, 0);\n            }\n            return first;\n        }\n        function siftUp(heap, node, i) {\n            var index = i;\n            while(index > 0){\n                var parentIndex = index - 1 >>> 1;\n                var parent = heap[parentIndex];\n                if (compare(parent, node) > 0) {\n                    // The parent is larger. Swap positions.\n                    heap[parentIndex] = node;\n                    heap[index] = parent;\n                    index = parentIndex;\n                } else {\n                    // The parent is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function siftDown(heap, node, i) {\n            var index = i;\n            var length = heap.length;\n            var halfLength = length >>> 1;\n            while(index < halfLength){\n                var leftIndex = (index + 1) * 2 - 1;\n                var left = heap[leftIndex];\n                var rightIndex = leftIndex + 1;\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n                if (compare(left, node) < 0) {\n                    if (rightIndex < length && compare(right, left) < 0) {\n                        heap[index] = right;\n                        heap[rightIndex] = node;\n                        index = rightIndex;\n                    } else {\n                        heap[index] = left;\n                        heap[leftIndex] = node;\n                        index = leftIndex;\n                    }\n                } else if (rightIndex < length && compare(right, node) < 0) {\n                    heap[index] = right;\n                    heap[rightIndex] = node;\n                    index = rightIndex;\n                } else {\n                    // Neither child is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function compare(a, b) {\n            // Compare sort index first, then task id.\n            var diff = a.sortIndex - b.sortIndex;\n            return diff !== 0 ? diff : a.id - b.id;\n        }\n        // TODO: Use symbols?\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {}\n        /* eslint-disable no-var */ var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n            var localPerformance = performance;\n            exports.unstable_now = function() {\n                return localPerformance.now();\n            };\n        } else {\n            var localDate = Date;\n            var initialTime = localDate.now();\n            exports.unstable_now = function() {\n                return localDate.now() - initialTime;\n            };\n        } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n        // Math.pow(2, 30) - 1\n        // 0b111111111111111111111111111111\n        var maxSigned31BitInt = 1073741823; // Times out immediately\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5000;\n        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n        var taskQueue = [];\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null; // IE and Node.js + jsdom\n        var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n            // Check for tasks that are no longer delayed and add them to the queue.\n            var timer = peek(timerQueue);\n            while(timer !== null){\n                if (timer.callback === null) {\n                    // Timer was cancelled.\n                    pop(timerQueue);\n                } else if (timer.startTime <= currentTime) {\n                    // Timer fired. Transfer to the task queue.\n                    pop(timerQueue);\n                    timer.sortIndex = timer.expirationTime;\n                    push(taskQueue, timer);\n                } else {\n                    // Remaining timers are pending.\n                    return;\n                }\n                timer = peek(timerQueue);\n            }\n        }\n        function handleTimeout(currentTime) {\n            isHostTimeoutScheduled = false;\n            advanceTimers(currentTime);\n            if (!isHostCallbackScheduled) {\n                if (peek(taskQueue) !== null) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                } else {\n                    var firstTimer = peek(timerQueue);\n                    if (firstTimer !== null) {\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                    }\n                }\n            }\n        }\n        function flushWork(hasTimeRemaining, initialTime) {\n            isHostCallbackScheduled = false;\n            if (isHostTimeoutScheduled) {\n                // We scheduled a timeout but it's no longer needed. Cancel it.\n                isHostTimeoutScheduled = false;\n                cancelHostTimeout();\n            }\n            isPerformingWork = true;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n                if (enableProfiling) {\n                    try {\n                        return workLoop(hasTimeRemaining, initialTime);\n                    } catch (error) {\n                        if (currentTask !== null) {\n                            var currentTime = exports.unstable_now();\n                            markTaskErrored(currentTask, currentTime);\n                            currentTask.isQueued = false;\n                        }\n                        throw error;\n                    }\n                } else {\n                    // No catch in prod code path.\n                    return workLoop(hasTimeRemaining, initialTime);\n                }\n            } finally{\n                currentTask = null;\n                currentPriorityLevel = previousPriorityLevel;\n                isPerformingWork = false;\n            }\n        }\n        function workLoop(hasTimeRemaining, initialTime) {\n            var currentTime = initialTime;\n            advanceTimers(currentTime);\n            currentTask = peek(taskQueue);\n            while(currentTask !== null && !enableSchedulerDebugging){\n                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n                    break;\n                }\n                var callback = currentTask.callback;\n                if (typeof callback === \"function\") {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    var continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = exports.unstable_now();\n                    if (typeof continuationCallback === \"function\") {\n                        currentTask.callback = continuationCallback;\n                    } else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                } else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n            } // Return whether there's additional work\n            if (currentTask !== null) {\n                return true;\n            } else {\n                var firstTimer = peek(timerQueue);\n                if (firstTimer !== null) {\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                }\n                return false;\n            }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                case LowPriority:\n                case IdlePriority:\n                    break;\n                default:\n                    priorityLevel = NormalPriority;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_next(eventHandler) {\n            var priorityLevel;\n            switch(currentPriorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                    // Shift down to normal priority\n                    priorityLevel = NormalPriority;\n                    break;\n                default:\n                    // Anything lower than normal priority should remain at the current level.\n                    priorityLevel = currentPriorityLevel;\n                    break;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_wrapCallback(callback) {\n            var parentPriorityLevel = currentPriorityLevel;\n            return function() {\n                // This is a fork of runWithPriority, inlined for performance.\n                var previousPriorityLevel = currentPriorityLevel;\n                currentPriorityLevel = parentPriorityLevel;\n                try {\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentPriorityLevel = previousPriorityLevel;\n                }\n            };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n            var currentTime = exports.unstable_now();\n            var startTime;\n            if (typeof options === \"object\" && options !== null) {\n                var delay = options.delay;\n                if (typeof delay === \"number\" && delay > 0) {\n                    startTime = currentTime + delay;\n                } else {\n                    startTime = currentTime;\n                }\n            } else {\n                startTime = currentTime;\n            }\n            var timeout;\n            switch(priorityLevel){\n                case ImmediatePriority:\n                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n                    break;\n                case UserBlockingPriority:\n                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n                    break;\n                case IdlePriority:\n                    timeout = IDLE_PRIORITY_TIMEOUT;\n                    break;\n                case LowPriority:\n                    timeout = LOW_PRIORITY_TIMEOUT;\n                    break;\n                case NormalPriority:\n                default:\n                    timeout = NORMAL_PRIORITY_TIMEOUT;\n                    break;\n            }\n            var expirationTime = startTime + timeout;\n            var newTask = {\n                id: taskIdCounter++,\n                callback: callback,\n                priorityLevel: priorityLevel,\n                startTime: startTime,\n                expirationTime: expirationTime,\n                sortIndex: -1\n            };\n            if (startTime > currentTime) {\n                // This is a delayed task.\n                newTask.sortIndex = startTime;\n                push(timerQueue, newTask);\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n                    // All tasks are delayed, and this is the task with the earliest delay.\n                    if (isHostTimeoutScheduled) {\n                        // Cancel an existing timeout.\n                        cancelHostTimeout();\n                    } else {\n                        isHostTimeoutScheduled = true;\n                    } // Schedule a timeout.\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\n                }\n            } else {\n                newTask.sortIndex = expirationTime;\n                push(taskQueue, newTask);\n                // wait until the next time we yield.\n                if (!isHostCallbackScheduled && !isPerformingWork) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                }\n            }\n            return newTask;\n        }\n        function unstable_pauseExecution() {}\n        function unstable_continueExecution() {\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n                isHostCallbackScheduled = true;\n                requestHostCallback(flushWork);\n            }\n        }\n        function unstable_getFirstCallbackNode() {\n            return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n            // remove from the queue because you can't remove arbitrary nodes from an\n            // array based heap, only the first one.)\n            task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n            return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var scheduledHostCallback = null;\n        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n        // thread, like user events. By default, it yields multiple times per frame.\n        // It does not attempt to align with frame boundaries, since most tasks don't\n        // need to be frame aligned; for those that do, use requestAnimationFrame.\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n            var timeElapsed = exports.unstable_now() - startTime;\n            if (timeElapsed < frameInterval) {\n                // The main thread has only been blocked for a really short amount of time;\n                // smaller than a single frame. Don't yield yet.\n                return false;\n            } // The main thread has been blocked for a non-negligible amount of time. We\n            return true;\n        }\n        function requestPaint() {}\n        function forceFrameRate(fps) {\n            if (fps < 0 || fps > 125) {\n                // Using console['error'] to evade Babel and ESLint\n                console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing frame rates higher than 125 fps is not supported\");\n                return;\n            }\n            if (fps > 0) {\n                frameInterval = Math.floor(1000 / fps);\n            } else {\n                // reset the framerate\n                frameInterval = frameYieldMs;\n            }\n        }\n        var performWorkUntilDeadline = function() {\n            if (scheduledHostCallback !== null) {\n                var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n                // has been blocked.\n                startTime = currentTime;\n                var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n                // error can be observed.\n                //\n                // Intentionally not using a try-catch, since that makes some debugging\n                // techniques harder. Instead, if `scheduledHostCallback` errors, then\n                // `hasMoreWork` will remain true, and we'll continue the work loop.\n                var hasMoreWork = true;\n                try {\n                    hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n                } finally{\n                    if (hasMoreWork) {\n                        // If there's more work, schedule the next message event at the end\n                        // of the preceding one.\n                        schedulePerformWorkUntilDeadline();\n                    } else {\n                        isMessageLoopRunning = false;\n                        scheduledHostCallback = null;\n                    }\n                }\n            } else {\n                isMessageLoopRunning = false;\n            } // Yielding to the browser will give it a chance to paint, so we can\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n            // Node.js and old IE.\n            // There's a few reasons for why we prefer setImmediate.\n            //\n            // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n            // (Even though this is a DOM fork of the Scheduler, you could get here\n            // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n            // https://github.com/facebook/react/issues/20756\n            //\n            // But also, it runs earlier which is the semantic we want.\n            // If other browsers ever implement it, it's better to use it.\n            // Although both of these would be inferior to native scheduling.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetImmediate(performWorkUntilDeadline);\n            };\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // DOM and Worker environments.\n            // We prefer MessageChannel because of the 4ms setTimeout clamping.\n            var channel = new MessageChannel();\n            var port = channel.port2;\n            channel.port1.onmessage = performWorkUntilDeadline;\n            schedulePerformWorkUntilDeadline = function() {\n                port.postMessage(null);\n            };\n        } else {\n            // We should only fallback here in non-browser environments.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetTimeout(performWorkUntilDeadline, 0);\n            };\n        }\n        function requestHostCallback(callback) {\n            scheduledHostCallback = callback;\n            if (!isMessageLoopRunning) {\n                isMessageLoopRunning = true;\n                schedulePerformWorkUntilDeadline();\n            }\n        }\n        function requestHostTimeout(callback, ms) {\n            taskTimeoutID = localSetTimeout(function() {\n                callback(exports.unstable_now());\n            }, ms);\n        }\n        function cancelHostTimeout() {\n            localClearTimeout(taskTimeoutID);\n            taskTimeoutID = -1;\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUVPO1FBRVYseUNBQXlDLEdBQ3pDLElBQ0UsT0FBT0MsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQkMsMkJBQTJCLEtBQy9ELFlBQ0Y7WUFDQUQsK0JBQStCQywyQkFBMkIsQ0FBQyxJQUFJQztRQUNqRTtRQUNVLElBQUlDLDJCQUEyQjtRQUN6QyxJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSUMsZUFBZTtRQUVuQixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLElBQUk7WUFDdEIsSUFBSUMsUUFBUUYsS0FBS0csTUFBTTtZQUN2QkgsS0FBS0QsSUFBSSxDQUFDRTtZQUNWRyxPQUFPSixNQUFNQyxNQUFNQztRQUNyQjtRQUNBLFNBQVNHLEtBQUtMLElBQUk7WUFDaEIsT0FBT0EsS0FBS0csTUFBTSxLQUFLLElBQUksT0FBT0gsSUFBSSxDQUFDLEVBQUU7UUFDM0M7UUFDQSxTQUFTTSxJQUFJTixJQUFJO1lBQ2YsSUFBSUEsS0FBS0csTUFBTSxLQUFLLEdBQUc7Z0JBQ3JCLE9BQU87WUFDVDtZQUVBLElBQUlJLFFBQVFQLElBQUksQ0FBQyxFQUFFO1lBQ25CLElBQUlRLE9BQU9SLEtBQUtNLEdBQUc7WUFFbkIsSUFBSUUsU0FBU0QsT0FBTztnQkFDbEJQLElBQUksQ0FBQyxFQUFFLEdBQUdRO2dCQUNWQyxTQUFTVCxNQUFNUSxNQUFNO1lBQ3ZCO1lBRUEsT0FBT0Q7UUFDVDtRQUVBLFNBQVNILE9BQU9KLElBQUksRUFBRUMsSUFBSSxFQUFFUyxDQUFDO1lBQzNCLElBQUlSLFFBQVFRO1lBRVosTUFBT1IsUUFBUSxFQUFHO2dCQUNoQixJQUFJUyxjQUFjVCxRQUFRLE1BQU07Z0JBQ2hDLElBQUlV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LHdDQUF3QyxHQUFHbUU7UUFDM0NuRSxxQ0FBcUMsR0FBR2lFO1FBQ3hDakUscUJBQXFCLEdBQUdxRDtRQUN4QnJELCtCQUErQixHQUFHK0Q7UUFDbEMvRCw2QkFBNkIsR0FBR3lGO1FBQ2hDekYsZ0NBQWdDLEdBQUdtRDtRQUNuQ25ELGlDQUFpQyxHQUFHMEQ7UUFDcEMxRCw0QkFBNEIsR0FBRytDO1FBQy9CL0MsNkJBQTZCLEdBQUdzRDtRQUN0Qix5Q0FBeUMsR0FDbkQsSUFDRSxPQUFPakcsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQjZJLDBCQUEwQixLQUM5RCxZQUNGO1lBQ0E3SSwrQkFBK0I2SSwwQkFBMEIsQ0FBQyxJQUFJM0k7UUFDaEU7SUFFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2UtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanM/YjExNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG52YXIgZW5hYmxlUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZnJhbWVZaWVsZE1zID0gNTtcblxuZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICBoZWFwLnB1c2gobm9kZSk7XG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgcmV0dXJuIGhlYXAubGVuZ3RoID09PSAwID8gbnVsbCA6IGhlYXBbMF07XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICBpZiAoaGVhcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gIHZhciBsYXN0ID0gaGVhcC5wb3AoKTtcblxuICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICBoZWFwWzBdID0gbGFzdDtcbiAgICBzaWZ0RG93bihoZWFwLCBsYXN0LCAwKTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdDtcbn1cblxuZnVuY3Rpb24gc2lmdFVwKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcblxuICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG4gICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuICB2YXIgbGVuZ3RoID0gaGVhcC5sZW5ndGg7XG4gIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuXG4gIHdoaWxlIChpbmRleCA8IGhhbGZMZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAoY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcbiAgICAgIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIGxlZnQpIDwgMCkge1xuICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuICAgICAgICBoZWFwW2xlZnRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbm9kZSkgPCAwKSB7XG4gICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIC8vIENvbXBhcmUgc29ydCBpbmRleCBmaXJzdCwgdGhlbiB0YXNrIGlkLlxuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiBkaWZmICE9PSAwID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuXG4vLyBUT0RPOiBVc2Ugc3ltYm9scz9cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDE7XG52YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xudmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbnZhciBMb3dQcmlvcml0eSA9IDQ7XG52YXIgSWRsZVByaW9yaXR5ID0gNTtcblxuZnVuY3Rpb24gbWFya1Rhc2tFcnJvcmVkKHRhc2ssIG1zKSB7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG52YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59IC8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuXG52YXIgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzOyAvLyBUaW1lcyBvdXQgaW1tZWRpYXRlbHlcblxudmFyIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7IC8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG5cbnZhciBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQgPSAyNTA7XG52YXIgTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQgPSA1MDAwO1xudmFyIExPV19QUklPUklUWV9USU1FT1VUID0gMTAwMDA7IC8vIE5ldmVyIHRpbWVzIG91dFxuXG52YXIgSURMRV9QUklPUklUWV9USU1FT1VUID0gbWF4U2lnbmVkMzFCaXRJbnQ7IC8vIFRhc2tzIGFyZSBzdG9yZWQgb24gYSBtaW4gaGVhcFxuXG52YXIgdGFza1F1ZXVlID0gW107XG52YXIgdGltZXJRdWV1ZSA9IFtdOyAvLyBJbmNyZW1lbnRpbmcgaWQgY291bnRlci4gVXNlZCB0byBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuXG5cbnZhciB0YXNrSWRDb3VudGVyID0gMTsgLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxudmFyIGN1cnJlbnRUYXNrID0gbnVsbDtcbnZhciBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5OyAvLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY2UuXG5cbnZhciBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG52YXIgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbnZhciBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7IC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuXG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogbnVsbDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiBudWxsO1xudmFyIGxvY2FsU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRJbW1lZGlhdGUgOiBudWxsOyAvLyBJRSBhbmQgTm9kZS5qcyArIGpzZG9tXG5cbnZhciBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcgIT09IHVuZGVmaW5lZCA/IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpIDogbnVsbDtcblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhdGNoIGluIHByb2QgY29kZSBwYXRoLlxuICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG4gICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpKSB7XG4gICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG5cbiAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKGRpZFVzZXJDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cblxuICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuICB2YXIgcHJpb3JpdHlMZXZlbDtcblxuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQW55dGhpbmcgbG93ZXIgdGhhbiBub3JtYWwgcHJpb3JpdHkgc2hvdWxkIHJlbWFpbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcnVuV2l0aFByaW9yaXR5LCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgdmFyIHN0YXJ0VGltZTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICBpZiAoc3RhcnRUaW1lID4gY3VycmVudFRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVsYXllZCB0YXNrLlxuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xuICAgIHB1c2godGltZXJRdWV1ZSwgbmV3VGFzayk7XG5cbiAgICBpZiAocGVlayh0YXNrUXVldWUpID09PSBudWxsICYmIG5ld1Rhc2sgPT09IHBlZWsodGltZXJRdWV1ZSkpIHtcbiAgICAgIC8vIEFsbCB0YXNrcyBhcmUgZGVsYXllZCwgYW5kIHRoaXMgaXMgdGhlIHRhc2sgd2l0aCB0aGUgZWFybGllc3QgZGVsYXkuXG4gICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAvLyBDYW5jZWwgYW4gZXhpc3RpbmcgdGltZW91dC5cbiAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgfSAvLyBTY2hlZHVsZSBhIHRpbWVvdXQuXG5cblxuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBleHBpcmF0aW9uVGltZTtcbiAgICBwdXNoKHRhc2tRdWV1ZSwgbmV3VGFzayk7XG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG5cbiAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Rhc2s7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uKCkge1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbigpIHtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSgpIHtcbiAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sodGFzaykge1xuICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxudmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG52YXIgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbnZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3Rcbi8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbnZhciBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xudmFyIHN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgdmFyIHRpbWVFbGFwc2VkID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZTtcblxuICBpZiAodGltZUVsYXBzZWQgPCBmcmFtZUludGVydmFsKSB7XG4gICAgLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBvbmx5IGJlZW4gYmxvY2tlZCBmb3IgYSByZWFsbHkgc2hvcnQgYW1vdW50IG9mIHRpbWU7XG4gICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRoZSBtYWluIHRocmVhZCBoYXMgYmVlbiBibG9ja2VkIGZvciBhIG5vbi1uZWdsaWdpYmxlIGFtb3VudCBvZiB0aW1lLiBXZVxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RQYWludCgpIHtcblxufVxuXG5mdW5jdGlvbiBmb3JjZUZyYW1lUmF0ZShmcHMpIHtcbiAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgY29uc29sZVsnZXJyb3InXSgnZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsICcgKyAnZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZnBzID4gMCkge1xuICAgIGZyYW1lSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuICB9XG59XG5cbnZhciBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBtZWFzdXJlIGhvdyBsb25nIHRoZSBtYWluIHRocmVhZFxuICAgIC8vIGhhcyBiZWVuIGJsb2NrZWQuXG5cbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB2YXIgaGFzVGltZVJlbWFpbmluZyA9IHRydWU7IC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAvLyBlcnJvciBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgLy9cbiAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhIHRyeS1jYXRjaCwgc2luY2UgdGhhdCBtYWtlcyBzb21lIGRlYnVnZ2luZ1xuICAgIC8vIHRlY2huaXF1ZXMgaGFyZGVyLiBJbnN0ZWFkLCBpZiBgc2NoZWR1bGVkSG9zdENhbGxiYWNrYCBlcnJvcnMsIHRoZW5cbiAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuXG4gICAgdmFyIGhhc01vcmVXb3JrID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChoYXNNb3JlV29yaykge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxufTtcblxudmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG5pZiAodHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIE5vZGUuanMgYW5kIG9sZCBJRS5cbiAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cbiAgLy9cbiAgLy8gVW5saWtlIE1lc3NhZ2VDaGFubmVsLCBpdCBkb2Vzbid0IHByZXZlbnQgYSBOb2RlLmpzIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxuICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDc1NlxuICAvL1xuICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAvLyBJZiBvdGhlciBicm93c2VycyBldmVyIGltcGxlbWVudCBpdCwgaXQncyBiZXR0ZXIgdG8gdXNlIGl0LlxuICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldEltbWVkaWF0ZShwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIERPTSBhbmQgV29ya2VyIGVudmlyb25tZW50cy5cbiAgLy8gV2UgcHJlZmVyIE1lc3NhZ2VDaGFubmVsIGJlY2F1c2Ugb2YgdGhlIDRtcyBzZXRUaW1lb3V0IGNsYW1waW5nLlxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBXZSBzaG91bGQgb25seSBmYWxsYmFjayBoZXJlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gIH0sIG1zKTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsSG9zdFRpbWVvdXQoKSB7XG4gIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICB0YXNrVGltZW91dElEID0gLTE7XG59XG5cbnZhciB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSByZXF1ZXN0UGFpbnQ7XG52YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gIG51bGw7XG5cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gdW5zdGFibGVfY29udGludWVFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZm9yY2VGcmFtZVJhdGU7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG5leHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU7XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gc2hvdWxkWWllbGRUb0hvc3Q7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQiLCJFcnJvciIsImVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyIsImVuYWJsZVByb2ZpbGluZyIsImZyYW1lWWllbGRNcyIsInB1c2giLCJoZWFwIiwibm9kZSIsImluZGV4IiwibGVuZ3RoIiwic2lmdFVwIiwicGVlayIsInBvcCIsImZpcnN0IiwibGFzdCIsInNpZnREb3duIiwiaSIsInBhcmVudEluZGV4IiwicGFyZW50IiwiY29tcGFyZSIsImhhbGZMZW5ndGgiLCJsZWZ0SW5kZXgiLCJsZWZ0IiwicmlnaHRJbmRleCIsInJpZ2h0IiwiYSIsImIiLCJkaWZmIiwic29ydEluZGV4IiwiaWQiLCJJbW1lZGlhdGVQcmlvcml0eSIsIlVzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkiLCJMb3dQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsIm1hcmtUYXNrRXJyb3JlZCIsInRhc2siLCJtcyIsImhhc1BlcmZvcm1hbmNlTm93IiwicGVyZm9ybWFuY2UiLCJub3ciLCJsb2NhbFBlcmZvcm1hbmNlIiwiZXhwb3J0cyIsInVuc3RhYmxlX25vdyIsImxvY2FsRGF0ZSIsIkRhdGUiLCJpbml0aWFsVGltZSIsIm1heFNpZ25lZDMxQml0SW50IiwiSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQiLCJVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQiLCJOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCIsIkxPV19QUklPUklUWV9USU1FT1VUIiwiSURMRV9QUklPUklUWV9USU1FT1VUIiwidGFza1F1ZXVlIiwidGltZXJRdWV1ZSIsInRhc2tJZENvdW50ZXIiLCJjdXJyZW50VGFzayIsImN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNQZXJmb3JtaW5nV29yayIsImlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIiwiaXNIb3N0VGltZW91dFNjaGVkdWxlZCIsImxvY2FsU2V0VGltZW91dCIsInNldFRpbWVvdXQiLCJsb2NhbENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsImxvY2FsU2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlIiwiaXNJbnB1dFBlbmRpbmciLCJuYXZpZ2F0b3IiLCJzY2hlZHVsaW5nIiwidW5kZWZpbmVkIiwiYmluZCIsImFkdmFuY2VUaW1lcnMiLCJjdXJyZW50VGltZSIsInRpbWVyIiwiY2FsbGJhY2siLCJzdGFydFRpbWUiLCJleHBpcmF0aW9uVGltZSIsImhhbmRsZVRpbWVvdXQiLCJyZXF1ZXN0SG9zdENhbGxiYWNrIiwiZmx1c2hXb3JrIiwiZmlyc3RUaW1lciIsInJlcXVlc3RIb3N0VGltZW91dCIsImhhc1RpbWVSZW1haW5pbmciLCJjYW5jZWxIb3N0VGltZW91dCIsInByZXZpb3VzUHJpb3JpdHlMZXZlbCIsIndvcmtMb29wIiwiZXJyb3IiLCJpc1F1ZXVlZCIsInNob3VsZFlpZWxkVG9Ib3N0IiwicHJpb3JpdHlMZXZlbCIsImRpZFVzZXJDYWxsYmFja1RpbWVvdXQiLCJjb250aW51YXRpb25DYWxsYmFjayIsInVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSIsImV2ZW50SGFuZGxlciIsInVuc3RhYmxlX25leHQiLCJ1bnN0YWJsZV93cmFwQ2FsbGJhY2siLCJwYXJlbnRQcmlvcml0eUxldmVsIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwib3B0aW9ucyIsImRlbGF5IiwidGltZW91dCIsIm5ld1Rhc2siLCJ1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uIiwidW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUiLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNNZXNzYWdlTG9vcFJ1bm5pbmciLCJzY2hlZHVsZWRIb3N0Q2FsbGJhY2siLCJ0YXNrVGltZW91dElEIiwiZnJhbWVJbnRlcnZhbCIsInRpbWVFbGFwc2VkIiwicmVxdWVzdFBhaW50IiwiZm9yY2VGcmFtZVJhdGUiLCJmcHMiLCJjb25zb2xlIiwiTWF0aCIsImZsb29yIiwicGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwiaGFzTW9yZVdvcmsiLCJzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9Qcm9maWxpbmciLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX0xvd1ByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMseUtBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BhY2UtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzZiYTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\n");

/***/ })

};
;